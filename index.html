<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>PCB ÁÑäÊé•Âä©Êâã (ÈÄÇÈÖç Name Âàó)</title>
<script src="https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js"></script>
<style>
  :root { --sidebar-bg:#2b2d30; --sidebar-text:#adb0b8; --accent:#4a88c7; --sel:#2675bf; --bg:#f0f2f5; }
  * { box-sizing:border-box; }
  body { margin:0; font-family:-apple-system,sans-serif; height:100vh; display:flex; overflow:hidden; background:var(--bg); }
  
  aside { width:320px; background:var(--sidebar-bg); color:var(--sidebar-text); display:flex; flex-direction:column; border-right:1px solid #1e1e1e; z-index:20; flex-shrink:0; }
  
  .header { padding:10px; background:#1e1f22; border-bottom:1px solid #3e4145; }
  .btn { display:block; background:var(--accent); color:#fff; text-align:center; padding:8px; border-radius:4px; font-size:14px; margin-bottom:8px; cursor:pointer; }
  .file-box { position:relative; overflow:hidden; }
  .file-box input { position:absolute; left:0; top:0; opacity:0; width:100%; height:100%; cursor:pointer; }
  input[type=text] { width:100%; padding:8px; background:#1e1f22; border:1px solid #555; color:#fff; border-radius:4px; margin-top:5px;}
  
  .opt-group { display:flex; gap:15px; font-size:13px; color:#ddd; margin-bottom:6px; align-items:center; }
  .opt-group label { display:flex; align-items:center; cursor:pointer; }
  .opt-group input { margin-right:4px; }
  .divider { height:1px; background:#444; margin:8px 0; }

  #list { flex:1; overflow-y:auto; -webkit-overflow-scrolling:touch; border-bottom: 1px solid #3e4145; }
  .item { padding:10px; border-bottom:1px solid #3e4145; cursor:pointer; }
  .item.active { background:var(--sel); color:#fff; }
  .item b { display:block; font-size:15px; }
  .item span { font-size:12px; opacity:0.8; }

  #info-panel { height: 160px; background: #232528; padding: 10px; overflow-y: auto; font-size: 13px; color: #ddd; flex-shrink: 0; }
  .info-row { display: flex; margin-bottom: 5px; border-bottom: 1px dashed #444; padding-bottom: 2px; }
  .info-label { width: 70px; color: #888; font-weight: bold; }
  .info-val { flex: 1; word-break: break-all; color: #fff; }

  main { flex:1; position:relative; background:radial-gradient(#ccc 1px, transparent 1px); background-size:20px 20px; overflow:hidden; touch-action:none; width: 100%; height: 100%; }
  canvas { display: block; width: 100%; height: 100%; position: absolute; top: 0; left: 0; }
  #reset { position:absolute; top:10px; right:10px; background:#fff; border:1px solid #999; padding:5px 10px; border-radius:4px; cursor:pointer; z-index:5; }
  
  @media(max-width:768px){ body{flex-direction:column-reverse;} aside{width:100%;height:45%;} main{height:55%;} #info-panel { height: 120px; } }
</style>
</head>
<body>

<aside>
  <div class="header">
    <div class="file-box">
      <div class="btn">üìÇ ÂØºÂÖ• Excel / CSV</div>
      <input type="file" id="file" accept=".csv,.txt,.xlsx,.xls">
    </div>
    <div class="opt-group" style="font-weight:bold; color:#fff;">
      <span>Â±ÇÁ∫ß:</span>
      <label><input type="radio" name="layer" value="T" checked> È°∂Â±Ç (Top)</label>
      <label><input type="radio" name="layer" value="B"> Â∫ïÂ±Ç (Bot)</label>
    </div>
    <div class="divider"></div>
    <div class="opt-group">
      <span>ÊòæÁ§∫:</span>
      <label><input type="radio" name="mode" value="value" checked> ÂèÇÊï∞</label>
      <label><input type="radio" name="mode" value="ref"> ‰ΩçÂè∑</label>
    </div>
    <input type="text" id="search" placeholder="üîç Êêú‰ΩçÂè∑/Name...">
  </div>
  <div id="list"><div style="padding:20px;text-align:center;opacity:0.5">ËØ∑ÂÖàÂØºÂÖ•Êñá‰ª∂</div></div>
  <div id="info-panel"><div style="color:#666; text-align:center; margin-top:40px;">ÈÄâ‰∏≠ÂÖÉ‰ª∂Êü•ÁúãËØ¶ÊÉÖ</div></div>
</aside>

<main>
  <button id="reset">ÂÖ®Â±èÈÄÇÂ∫î</button>
  <canvas id="pcb"></canvas>
</main>

<script>
// ========== 1. ÂèÇÊï∞ÊèêÂèñ ==========
const SHAPES = { CHIP:1, SOT:2, SOP:3, QFP:4, CIRCLE:6, DEFAULT:0 };

function extractParams(fp) {
  const s = (fp || "").toUpperCase();
  const p = { L:null, W:null, P:null, LS:null, pins:null };
  const matchVal = key => { const m = s.match(new RegExp(`[-_\\s]${key}([\\d.]+)`)); return m ? parseFloat(m[1]) : null; };
  p.L = matchVal("L"); p.W = matchVal("W"); p.P = matchVal("P"); p.LS = matchVal("LS");
  const sotMatch = s.match(/SOT[-_]?23[-_](\d+)/); 
  if (sotMatch) p.pins = parseInt(sotMatch[1]);
  else if (s.match(/(\d+)(?:-|_)?(?:PIN|P)(?=[-_]|$)/)) p.pins = parseInt(s.match(/(\d+)(?:-|_)?(?:PIN|P)(?=[-_]|$)/)[1]);
  else if (s.includes("SOT-23") || s.includes("SOT23")) p.pins = 3;
  else { const suffix = s.match(/(?:SOP|SOIC|TSSOP|QFN|QFP|DIP)[-_]?(\d+)/); if (suffix) p.pins = parseInt(suffix[1]); }
  return p;
}

function analyzeFootprint(fp) {
  const s = (fp||"").toUpperCase();
  const p = extractParams(fp);
  let type = SHAPES.DEFAULT;
  if(s.includes("0402")||s.includes("0603")||s.includes("0805")||s.includes("1206")||s.match(/^R\d+/)||s.match(/^C\d+/)) type = SHAPES.CHIP;
  else if(s.includes("SOT")) type = SHAPES.SOT;
  else if(s.includes("SOP")||s.includes("SOIC")) type = SHAPES.SOP;
  else if(s.includes("QFP")||s.includes("QFN")) type = SHAPES.QFP;
  else if(s.includes("RADIAL")||s.includes("CAN")) type = SHAPES.CIRCLE;
  return { type, ...p };
}

function calculateBounds(fp, info) {
  let w=2.0, h=1.0;
  const { L, W, LS, type } = info;
  if(type===SHAPES.SOT) { w = L || 2.9; h = LS || ((W||1.3)+1.1); } 
  else if(type===SHAPES.SOP) { w = L || ((info.pins||8)/2 * 1.27 + 1.0); h = LS || ((W||3.9)+2.0); } 
  else if(type===SHAPES.CHIP) { if(L) w=L; if(W) h=W; else if(fp.toUpperCase().includes("0603")){w=1.6;h=0.8;} else if(fp.toUpperCase().includes("0805")){w=2.0;h=1.25;} } 
  else { if(L) w=L; if(W) h=W; }
  return { w, h };
}

// ========== 2. ÁªòÂõæÂºïÊìé ==========
function drawComponent(ctx, c, isSel) {
  const info = c.shapeInfo;
  const w = c.w, h = c.h;
  const color = isSel ? "#d00" : "#666";
  const fill = isSel ? "rgba(255,0,0,0.2)" : "#fff";
  const padFill = isSel ? "rgba(255,0,0,0.6)" : "#ccc";
  
  ctx.lineWidth = isSel ? 0.2 : 0.1;
  ctx.strokeStyle = color; ctx.fillStyle = fill;

  if(info.type === SHAPES.SOT) {
    ctx.rotate(270 * Math.PI / 180); 
    const bodyH = info.W || (h * 0.55);
    const pins = info.pins || 3;
    const P = info.P || 0.95;
    const padW = 0.5, padLen = (h - bodyH)/2;
    ctx.fillRect(-w/2, -bodyH/2, w, bodyH); ctx.strokeRect(-w/2, -bodyH/2, w, bodyH);
    ctx.beginPath(); ctx.arc(-w/2+0.4, -bodyH/2+0.4, 0.15, 0, 2*Math.PI); ctx.fillStyle = isSel?"red":"#999"; ctx.fill();
    ctx.fillStyle = padFill;
    if(pins === 3) {
      ctx.fillRect(-P/2-padW/2, -bodyH/2, padW, -padLen); 
      ctx.fillRect(P/2-padW/2, -bodyH/2, padW, -padLen); 
      ctx.fillRect(-padW/2, bodyH/2, padW, padLen); 
    } else if(pins === 5) {
      ctx.fillRect(-P-padW/2, -bodyH/2, padW, -padLen); ctx.fillRect(-padW/2, -bodyH/2, padW, -padLen); ctx.fillRect(P-padW/2, -bodyH/2, padW, -padLen);
      ctx.fillRect(P-padW/2, bodyH/2, padW, padLen); ctx.fillRect(-P-padW/2, bodyH/2, padW, padLen);
    } else if(pins === 6) {
       for(let i of [-1, 0, 1]) { ctx.fillRect(i*P-padW/2, -bodyH/2, padW, -padLen); ctx.fillRect(i*P-padW/2, bodyH/2, padW, padLen); }
    } else {
      const side = Math.ceil(pins/2), startX = -((side-1)*P)/2;
      for(let i=0; i<side; i++) { 
        ctx.fillRect(startX+i*P-padW/2, -bodyH/2, padW, -padLen); 
        if (i+side<pins) ctx.fillRect(startX+i*P-padW/2, bodyH/2, padW, padLen); 
      }
    }
    ctx.rotate(-270 * Math.PI / 180);
  }
  else if(info.type === SHAPES.SOP) {
    const bodyH = info.W || (h * 0.6);
    ctx.fillRect(-w/2, -bodyH/2, w, bodyH); ctx.strokeRect(-w/2, -bodyH/2, w, bodyH);
    ctx.beginPath(); ctx.arc(-w/2+w*0.1, -bodyH/2+bodyH*0.2, 0.2, 0, 2*Math.PI); ctx.fillStyle = isSel?"red":"#999"; ctx.fill();
    ctx.fillStyle = padFill;
    const sidePins = Math.floor((info.pins||8)/2), P = info.P || 1.27, startX = -((sidePins - 1) * P) / 2, padW = P*0.5, padLen = (h-bodyH)/2;
    for(let i=0; i<sidePins; i++) { const px = startX + i*P; ctx.fillRect(px-padW/2, -h/2, padW, padLen); ctx.fillRect(px-padW/2, bodyH/2, padW, padLen); }
  }
  else if(info.type === SHAPES.CHIP) {
    const padW = w*0.25;
    ctx.fillStyle = padFill; ctx.fillRect(-w/2, -h/2, padW, h); ctx.fillRect(w/2-padW, -h/2, padW, h);
    ctx.fillStyle = fill; ctx.fillRect(-w/2+padW, -h/2, w-2*padW, h); ctx.strokeRect(-w/2, -h/2, w, h);
  }
  else if(info.type === SHAPES.CIRCLE) {
    const r=Math.min(w,h)/2; ctx.beginPath(); ctx.arc(0,0,r,0,2*Math.PI); ctx.fill(); ctx.stroke(); ctx.fillStyle="#333"; ctx.fillRect(-r/2,-r,r,r/2);
  }
  else {
    ctx.fillRect(-w/2, -h/2, w, h); ctx.strokeRect(-w/2, -h/2, w, h);
    ctx.beginPath(); ctx.arc(-w/2+w*0.15, -h/2+h*0.15, Math.min(w,h)*0.1, 0, 2*Math.PI); ctx.fillStyle = isSel?"red":"#ccc"; ctx.fill();
  }
}

// ========== 3. Ëß£Êûê ==========
function parseRows(rows) {
  if (!rows || rows.length < 2) return [];
  let hIdx = 0;
  // Êô∫ËÉΩÂØªÊâæË°®Â§¥ (ÂåÖÂê´ Designator Êàñ Ref)
  for(let i=0;i<Math.min(rows.length,5);i++){ const s=rows[i].join(" ").toLowerCase(); if(s.includes("designator")||s.includes("mid x")) { hIdx=i; break; } }
  
  const h = rows[hIdx].map(x=>String(x).trim().toLowerCase());
  const find = ks => h.findIndex(c => ks.some(k => c.includes(k)));
  
  const iRef=find(["designator","ref"]);
  const iX=find(["mid x","x(mm)"]);
  const iY=find(["mid y","y(mm)"]);
  const iRot=find(["rotation","angle"]);
  const iLayer=find(["layer","Â±Ç"]);
  const iVal=find(["value","ÂÄº"]);
  const iFp=find(["footprint","Â∞ÅË£Ö"]);
  // „ÄêÂÖ≥ÈîÆ‰øÆÊîπ„Äë‰∏çÂÜçÊâæ comment/Â§áÊ≥®ÔºåËÄåÊòØÊâæ name
  const iName=find(["name", "comment", "Â§áÊ≥®", "device"]); 
  
  if(iRef<0 || iX<0 || iY<0) return [];
  
  const num = v => parseFloat(String(v).replace(/mm/g,"")) || 0;
  const arr = [];
  
  for(let i=hIdx+1; i<rows.length; i++){
    const r=rows[i]; if(!r || !r[iRef]) continue;
    const fp = iFp>=0 ? String(r[iFp]||"") : "";
    const layerRaw = iLayer>=0 ? String(r[iLayer]||"").toUpperCase() : "T";
    const isBot = layerRaw.includes("B") || layerRaw.includes("BOTTOM");
    const info = analyzeFootprint(fp);
    const bounds = calculateBounds(fp, info);
    
    // „ÄêÂÖ≥ÈîÆ‰øÆÊîπ„Äë‰øùÂ≠ò‰∏∫ name Â≠óÊÆµ
    const nameStr = iName>=0 ? String(r[iName]||"") : "";
    
    arr.push({ ref: r[iRef], x: num(r[iX]), y: num(r[iY]), angle: iRot>=0?num(r[iRot]):0, layer: isBot ? "B" : "T", w: bounds.w, h: bounds.h, val: iVal>=0?String(r[iVal]||""):"", name: nameStr, fp: fp, shapeInfo: info });
  }
  return arr;
}

// ========== 4. Viewer ==========
function makeViewer(allComps){
  const cvs = document.getElementById("pcb");
  const ctx = cvs.getContext("2d");
  const dpr = window.devicePixelRatio || 1;
  let t = { k:15, x:0, y:0 }, sel = null, drag = false, last = {x:0,y:0}, lDist = 0;
  let filteredComps = [];

  function updateFilter() {
    const curLayer = document.querySelector('input[name="layer"]:checked').value;
    filteredComps = allComps.filter(c => c.layer === curLayer);
    renderList(); draw(); 
  }

  function renderList() {
    const list = document.getElementById("list"); list.innerHTML = "";
    const k = document.getElementById("search").value.toUpperCase();
    const toShow = filteredComps.filter(c => c.ref.includes(k) || (c.val+c.name).toUpperCase().includes(k)).slice(0, 500);
    if(!toShow.length) { list.innerHTML="<div style='padding:20px;text-align:center;color:#666'>ÂΩìÂâçÂ±ÇÊó†Êï∞ÊçÆ</div>"; return;}
    toShow.forEach(c => {
      const div = document.createElement("div"); div.className = "item"; div.id = "i-"+c.ref;
      const v = (c.val && c.val!=="-") ? c.val : c.name;
      div.innerHTML = `<b>${c.ref}</b><span>${v||""} ${c.fp}</span>`;
      div.onclick = () => highlight(c.ref);
      list.appendChild(div);
    });
  }

  function fit() {
    resize();
    if(!filteredComps.length) { draw(); return; }
    let x0=1e9,x1=-1e9,y0=1e9,y1=-1e9;
    filteredComps.forEach(c=>{ x0=Math.min(x0,c.x-c.w/2); x1=Math.max(x1,c.x+c.w/2); y0=Math.min(y0,c.y-c.h/2); y1=Math.max(y1,c.y+c.h/2); });
    const boardW = x1 - x0; const boardH = y1 - y0;
    const screenW = cvs.width / dpr; const screenH = cvs.height / dpr;
    const scale = Math.min(screenW / (boardW || 10), screenH / (boardH || 10)) * 0.9;
    t.k = scale; t.x = screenW/2 - (x0 + x1)/2 * scale; t.y = screenH/2 + (y0 + y1)/2 * scale; 
    draw();
  }

  function draw() {
    const W = cvs.width/dpr, H = cvs.height/dpr;
    ctx.clearRect(0,0,W,H);
    if(!filteredComps.length && allComps.length > 0) {
        ctx.save(); ctx.scale(1,1); ctx.font="20px Arial"; ctx.fillStyle="#999"; ctx.textAlign="center";
        const curLayer = document.querySelector('input[name="layer"]:checked').value;
        ctx.fillText(`ÂΩìÂâçÂ±Ç (${curLayer === 'T' ? 'È°∂Â±Ç' : 'Â∫ïÂ±Ç'}) Êó†ÂåπÈÖçÂÖÉ‰ª∂`, W/2, H/2);
        ctx.restore(); return;
    }
    ctx.save();
    ctx.translate(t.x, t.y); ctx.scale(t.k, -t.k);
    const curLayer = document.querySelector('input[name="layer"]:checked').value;
    if(curLayer === 'B') ctx.scale(-1, 1);
    const mode = document.querySelector('input[name="mode"]:checked').value;
    filteredComps.forEach(c => {
      const isSel = (c.ref === sel);
      ctx.save();
      ctx.translate(c.x, c.y);
      ctx.rotate(c.angle * Math.PI/180);
      drawComponent(ctx, c, isSel);
      ctx.restore();
      if(c.w * t.k > 15) {
        ctx.save(); ctx.translate(c.x, c.y); 
        if(curLayer === 'B') ctx.scale(-1, 1); ctx.scale(1, -1); 
        let txt = c.ref;
        if(mode==="value") { const v = (c.val && c.val!=="-") ? c.val : c.name; if(v && v!=="-") txt = v; }
        let fs = 12/t.k; if(fs>2) fs=2; if(fs<0.2) fs=0.2;
        ctx.font = `bold ${fs}px Arial`; ctx.textAlign="center"; ctx.textBaseline="middle";
        ctx.fillStyle = isSel ? "#d00" : "#333";
        ctx.fillText(txt, 0, 0);
        ctx.restore();
      }
    });
    ctx.restore();
  }

  function resize() {
    const r = cvs.parentElement.getBoundingClientRect();
    const w = Math.floor(r.width * dpr), h = Math.floor(r.height * dpr);
    if(cvs.width !== w || cvs.height !== h) { cvs.width = w; cvs.height = h; ctx.scale(dpr, dpr); }
    cvs.style.width = r.width + "px"; cvs.style.height = r.height + "px";
  }
  window.onresize = () => { resize(); draw(); };
  setTimeout(resize, 100);

  cvs.onwheel = e => { e.preventDefault(); const r=cvs.getBoundingClientRect(); zoom(e.clientX-r.left, e.clientY-r.top, e.deltaY>0?0.9:1.1); };
  function zoom(mx,my,d) { t.x = mx-(mx-t.x)*d; t.y = my-(my-t.y)*d; t.k*=d; draw(); }
  cvs.onmousedown = e => { drag=true; last={x:e.clientX,y:e.clientY}; };
  window.onmousemove = e => { if(drag){ t.x+=e.clientX-last.x; t.y+=e.clientY-last.y; last={x:e.clientX,y:e.clientY}; draw(); } };
  window.onmouseup = () => drag=false;
  cvs.ontouchstart = e => { if(e.touches.length==1){drag=true;last={x:e.touches[0].clientX,y:e.touches[0].clientY}} else if(e.touches.length==2){drag=false;const t1=e.touches[0],t2=e.touches[1];lDist=Math.hypot(t2.clientX-t1.clientX,t2.clientY-t1.clientY)} };
  cvs.ontouchmove = e => { e.preventDefault(); if(e.touches.length==1&&drag){t.x+=e.touches[0].clientX-last.x;t.y+=e.touches[0].clientY-last.y;last={x:e.touches[0].clientX,y:e.touches[0].clientY};draw();} else if(e.touches.length==2){const t1=e.touches[0],t2=e.touches[1],dist=Math.hypot(t2.clientX-t1.clientX,t2.clientY-t1.clientY),cx=(t1.clientX+t2.clientX)/2-cvs.getBoundingClientRect().left,cy=(t1.clientY+t2.clientY)/2-cvs.getBoundingClientRect().top;zoom(cx,cy,dist/lDist);lDist=dist;} };

  let dX=0,dY=0;
  const start=e=>{dX=e.clientX||e.touches[0].clientX;dY=e.clientY||e.touches[0].clientY};
  const end=e=>{const cx=e.clientX||e.changedTouches[0].clientX,cy=e.clientY||e.changedTouches[0].clientY;if(Math.hypot(cx-dX,cy-dY)<10) hit(cx,cy)};
  cvs.addEventListener("mousedown",start); cvs.addEventListener("mouseup",end);
  cvs.addEventListener("touchstart",start); cvs.addEventListener("touchend",end);

  function hit(sx, sy) {
    const r = cvs.getBoundingClientRect();
    const curLayer = document.querySelector('input[name="layer"]:checked').value;
    let px = sx - r.left - t.x;
    let py = sy - r.top - t.y;
    if(curLayer === 'B') px = -px; 
    const wx = px / t.k;
    const wy = py / -t.k;
    let h = null;
    for(let c of filteredComps) { if(Math.abs(wx-c.x)<=c.w/2 && Math.abs(wy-c.y)<=c.h/2) { h=c; break; } }
    highlight(h ? h.ref : null);
  }

  // „ÄêÂÖ≥ÈîÆ‰øÆÊîπ„ÄëÊòæÁ§∫ Name
  function updateInfo(c) {
    const p = document.getElementById("info-panel");
    if(!c) { p.innerHTML = "<div style='color:#666;text-align:center;margin-top:40px;'>ÈÄâ‰∏≠ÂÖÉ‰ª∂Êü•ÁúãËØ¶ÊÉÖ</div>"; return; }
    // ËøôÈáåÁöÑÂ§áÊ≥®ÊîπÊàê‰∫Ü Name
    const rows = [ ["‰ΩçÂè∑",c.ref], ["ÂÄº",c.val], ["Name",c.name], ["Â∞ÅË£Ö",c.fp], ["ÂùêÊ†á",`${c.x}, ${c.y}`], ["ËßíÂ∫¶",c.angle+"¬∞"], ["Â±ÇÁ∫ß",c.layer==='T'?"Top":"Bottom"] ];
    let html = ""; rows.forEach(([k,v]) => { html += `<div class="info-row"><div class="info-label">${k}</div><div class="info-val">${v||'-'}</div></div>`; });
    p.innerHTML = html;
  }

  function highlight(ref) {
    sel = ref; draw();
    const el = document.getElementById("i-"+ref);
    if(el) {
      document.querySelectorAll(".active").forEach(e=>e.classList.remove("active"));
      el.classList.add("active");
      el.scrollIntoView({block:"nearest"});
      const c = filteredComps.find(x => x.ref === ref);
      updateInfo(c);
    }
  }

  document.getElementById("reset").onclick = fit;
  return { load: ()=>{ updateFilter(); fit(); }, update: updateFilter, highlight: highlight };
}

// ========== 5. Init ==========
let comps = [];
let viewer = null;
const fileIn = document.getElementById("file");

fileIn.onchange = e => {
  const f = e.target.files[0];
  if(!f) return;
  const r = new FileReader();
  r.onload = evt => {
    let rows = [];
    const d = evt.target.result;
    if(f.name.match(/\.xls/)) {
      try { const wb=XLSX.read(d,{type:'array'}); rows=XLSX.utils.sheet_to_json(wb.Sheets[wb.SheetNames[0]],{header:1}); } 
      catch(e){alert("ExcelËØªÂèñÂ§±Ë¥•");return;}
    } else {
      const txt = new TextDecoder().decode(new Uint8Array(d));
      rows = txt.split(/\r?\n/).map(l=>l.split(/,|\t/));
    }
    comps = parseRows(rows);
    if(!comps.length) return alert("Êú™ÊâæÂà∞Êï∞ÊçÆ (ËØ∑Ê£ÄÊü•LayerÂàó)");
    viewer = makeViewer(comps);
    viewer.load();
    document.querySelector('.btn').textContent = "üìÇ " + f.name;
  };
  r.readAsArrayBuffer(f);
};

document.querySelectorAll('input[type="radio"]').forEach(r => {
  r.addEventListener('change', () => { if(viewer) viewer.update(); });
});
document.getElementById("search").oninput = () => { if(viewer) viewer.update(); };
</script>
</body>
</html>

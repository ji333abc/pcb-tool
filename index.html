<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>PCB ÁÑäÊé•Âä©Êâã</title>
<script src="https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js"></script>
<style>
  :root { --sidebar-bg:#2b2d30; --sidebar-text:#adb0b8; --accent:#4a88c7; --sel:#2675bf; --bg:#f0f2f5; --checked: #4caf50; }
  * { box-sizing:border-box; outline:none; -webkit-tap-highlight-color: transparent; }
  body { margin:0; font-family:-apple-system,sans-serif; height:100vh; display:flex; overflow:hidden; background:var(--bg); }
  
  aside { width:320px; background:var(--sidebar-bg); color:var(--sidebar-text); display:flex; flex-direction:column; border-right:1px solid #1e1e1e; z-index:20; flex-shrink:0; }
  
  .header { padding:10px; background:#1e1f22; border-bottom:1px solid #3e4145; }
  .btn { display:block; background:var(--accent); color:#fff; text-align:center; padding:8px; border-radius:4px; font-size:14px; margin-bottom:8px; cursor:pointer; }
  .file-box { position:relative; overflow:hidden; }
  .file-box input { position:absolute; left:0; top:0; opacity:0; width:100%; height:100%; cursor:pointer; }
  
  input[type=text] { width:100%; padding:8px; background:#1e1f22; border:1px solid #555; color:#fff; border-radius:4px; margin-top:5px; font-size:16px; }
  
  .opt-group { display:flex; gap:15px; font-size:13px; color:#ddd; margin-bottom:6px; align-items:center; }
  .opt-group label { display:flex; align-items:center; cursor:pointer; padding: 5px 0; }
  .opt-group input { margin-right:4px; }
  .divider { height:1px; background:#444; margin:8px 0; }
  
  #list { flex:1; overflow-y:auto; -webkit-overflow-scrolling:touch; border-bottom: 1px solid #3e4145; }
  .item { padding:12px 10px; border-bottom:1px solid #3e4145; cursor:pointer; display:flex; justify-content:space-between; align-items:center; }
  .item.active { background:var(--sel); color:#fff; }
  .item.checked .ref { text-decoration: line-through; color: var(--checked); }
  .item b { display:block; font-size:15px; }
  .item span { font-size:12px; opacity:0.8; }
  
  #info-panel { height: 140px; background: #232528; padding: 10px; overflow-y: auto; font-size: 13px; color: #ddd; flex-shrink: 0; }
  .info-row { display: flex; margin-bottom: 5px; border-bottom: 1px dashed #444; padding-bottom: 2px; }
  .info-label { width: 70px; color: #888; font-weight: bold; }
  .info-val { flex: 1; word-break: break-all; color: #fff; }
  
  main { flex:1; position:relative; background:radial-gradient(#ccc 1px, transparent 1px); background-size:20px 20px; overflow:hidden; touch-action:none; width: 100%; height: 100%; }
  canvas { display: block; width: 100%; height: 100%; position: absolute; top: 0; left: 0; }
  
  #reset { position:absolute; top:10px; right:10px; background:#fff; border:1px solid #999; padding:6px 12px; border-radius:4px; cursor:pointer; z-index:5; box-shadow: 0 2px 5px rgba(0,0,0,0.2); font-size: 14px; }
  
  .toast { position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.7); color: #fff; padding: 8px 16px; border-radius: 20px; font-size: 14px; pointer-events: none; opacity: 0; transition: opacity 0.3s; z-index: 100; }
  .toast.show { opacity: 1; }

  @media(max-width:768px){ 
    body { flex-direction: column-reverse; } 
    aside { width: 100%; height: 45%; }
    main { height: 55%; }
    #info-panel { height: 100px; }
  }
</style>
</head>
<body>

<aside>
  <div class="header">
    <div class="file-box">
      <div class="btn">üìÇ ÂØºÂÖ• Excel / CSV</div>
      <input type="file" id="file" accept=".csv,.txt,.xlsx,.xls">
    </div>
    <div class="opt-group" style="font-weight:bold; color:#fff;">
      <span>Â±ÇÁ∫ß:</span>
      <label><input type="radio" name="layer" value="T" checked> È°∂Â±Ç (Top)</label>
      <label><input type="radio" name="layer" value="B"> Â∫ïÂ±Ç (Bot)</label>
    </div>
    <div class="divider"></div>
    <div class="opt-group">
      <span>ÊòæÁ§∫:</span>
      <label><input type="radio" name="mode" value="value" checked> ÂèÇÊï∞</label>
      <label><input type="radio" name="mode" value="ref"> ‰ΩçÂè∑</label>
    </div>
    <input type="text" id="search" placeholder="üîç Êêú‰ΩçÂè∑/Name...">
  </div>
  <div id="list"><div style="padding:20px;text-align:center;opacity:0.5">ËØ∑ÂÖàÂØºÂÖ•Êñá‰ª∂</div></div>
  <div id="info-panel"><div style="color:#666; text-align:center; margin-top:40px;">ÈÄâ‰∏≠ÂÖÉ‰ª∂Êü•ÁúãËØ¶ÊÉÖ</div></div>
</aside>

<main>
  <div id="toast" class="toast"></div>
  <button id="reset">ÂÖ®Â±èÈÄÇÂ∫î</button>
  <canvas id="pcb"></canvas>
</main>

<script>
const SHAPES = { CHIP:1, SOT:2, SOP:3, QFP:4, CIRCLE:6, DEFAULT:0 };
const SMD_SIZES = { "01005": { w: 0.4, h: 0.2 }, "0201": { w: 0.6, h: 0.3 }, "0402": { w: 1.0, h: 0.5 }, "0603": { w: 1.6, h: 0.8 }, "0805": { w: 2.0, h: 1.25 }, "1206": { w: 3.2, h: 1.6 }, "1210": { w: 3.2, h: 2.5 }, "1812": { w: 4.5, h: 3.2 }, "2010": { w: 5.0, h: 2.5 }, "2512": { w: 6.35, h: 3.2 } };

function showToast(msg) { const t = document.getElementById('toast'); t.textContent = msg; t.classList.add('show'); setTimeout(() => t.classList.remove('show'), 1500); }

function extractParams(fp) {
  const s = (fp || "").toUpperCase();
  const p = { L:null, W:null, pins:null, sizeCode: null };
  const matchVal = key => { const m = s.match(new RegExp(`[-_\\s]${key}([\\d.]+)`)); return m ? parseFloat(m[1]) : null; };
  p.L = matchVal("L"); p.W = matchVal("W"); p.P = matchVal("P");
  const sotMatch = s.match(/SOT[-_]?23[-_](\d+)/); 
  if (sotMatch) p.pins = parseInt(sotMatch[1]);
  else if (s.match(/(\d+)(?:-|_)?(?:PIN|P)(?=[-_]|$)/)) p.pins = parseInt(s.match(/(\d+)(?:-|_)?(?:PIN|P)(?=[-_]|$)/)[1]);
  else if (s.includes("SOT-23") || s.includes("SOT23")) p.pins = 3;
  else { const suffix = s.match(/(?:SOP|SOIC|TSSOP|QFN|QFP|DIP)[-_]?(\d+)/); if (suffix) p.pins = parseInt(suffix[1]); }
  for (let key in SMD_SIZES) { const reg = new RegExp(`(^|[^0-9])${key}([^0-9]|$)`); if (reg.test(s) || s.includes("C"+key) || s.includes("R"+key)) { p.sizeCode = key; break; } }
  return p;
}

function analyzeFootprint(fp) {
  const s = (fp||"").toUpperCase();
  const p = extractParams(fp);
  let type = SHAPES.DEFAULT;
  if(p.sizeCode || s.match(/^[RC]\d+/) || s.includes("RES") || s.includes("CAP") || s.includes("IND")) type = SHAPES.CHIP;
  else if(s.includes("SOT")) type = SHAPES.SOT;
  else if(s.includes("SOP")||s.includes("SOIC")) type = SHAPES.SOP;
  else if(s.includes("QFP")||s.includes("QFN")) type = SHAPES.QFP;
  else if(s.includes("RADIAL")||s.includes("CAN")||s.includes("ELECT")) type = SHAPES.CIRCLE;
  return { type, ...p };
}

function calculateBounds(fp, info) {
  let w=2.0, h=1.0; const { L, W, type, sizeCode } = info;
  if(type === SHAPES.SOT) { w = L || 2.9; h = ((W||1.3)+1.1); } 
  else if(type === SHAPES.SOP) { w = L || ((info.pins||8)/2 * 1.27 + 1.0); h = ((W||3.9)+2.0); } 
  else if(type === SHAPES.CHIP) { if (sizeCode && SMD_SIZES[sizeCode]) { w = SMD_SIZES[sizeCode].w; h = SMD_SIZES[sizeCode].h; } else { if(L) w=L; if(W) h=W; } } 
  else { if(L) w=L; if(W) h=W; }
  if(w < 0.2) w = 0.5; if(h < 0.2) h = 0.5;
  return { w, h };
}

// ÁªòÂõæÂáΩÊï∞ (‰øùÊåÅ‰Ω†ÁöÑÂÆåÁæéÁâàÈÄªËæë)
function drawComponent(ctx, c, status) {
  const info = c.shapeInfo; const w = c.w, h = c.h;
  let color = "#666", fill = "#fff", padFill = "#ccc";
  if (status.isChecked) { color = "#2e7d32"; fill = "#e8f5e9"; padFill = "#a5d6a7"; }
  if (status.isMatch) { color = "#0056b3"; fill = "rgba(0,123,255,0.2)"; padFill = "rgba(0,123,255,0.5)"; }
  if (status.isSel) { color = "#fbc02d"; fill = "rgba(251, 192, 45, 0.3)"; padFill = "rgba(251, 192, 45, 0.6)"; }
  if (status.isHover) { color = "#d50000"; fill = "rgba(255,0,0,0.3)"; padFill = "rgba(255,0,0,0.7)"; }

  ctx.lineWidth = (status.isSel || status.isHover) ? 0.2 : 0.1;
  ctx.strokeStyle = color; ctx.fillStyle = fill;

  if(info.type === SHAPES.SOT) {
    ctx.rotate(90 * Math.PI / 180); 
    const bodyH = info.W || (h * 0.55); const pins = info.pins || 3; const P = info.P || 0.95;
    const padW = 0.5, padLen = (h - bodyH)/2;
    ctx.fillRect(-w/2, -bodyH/2, w, bodyH); ctx.strokeRect(-w/2, -bodyH/2, w, bodyH);
    ctx.beginPath(); ctx.arc(-w/2+0.4, -bodyH/2+0.4, 0.15, 0, 2*Math.PI); ctx.fillStyle = status.isHover?"red":"#999"; ctx.fill();
    ctx.fillStyle = padFill;
    if(pins === 3) {
      ctx.fillRect(-P/2-padW/2, -bodyH/2, padW, -padLen); ctx.fillRect(P/2-padW/2, -bodyH/2, padW, -padLen); ctx.fillRect(-padW/2, bodyH/2, padW, padLen); 
    } else if(pins === 5) {
      ctx.fillRect(-P-padW/2, -bodyH/2, padW, -padLen); ctx.fillRect(-padW/2, -bodyH/2, padW, -padLen); ctx.fillRect(P-padW/2, -bodyH/2, padW, -padLen);
      ctx.fillRect(P-padW/2, bodyH/2, padW, padLen); ctx.fillRect(-P-padW/2, bodyH/2, padW, padLen);
    } else if(pins === 6) {
       for(let i of [-1, 0, 1]) { ctx.fillRect(i*P-padW/2, -bodyH/2, padW, -padLen); ctx.fillRect(i*P-padW/2, bodyH/2, padW, padLen); }
    } else {
      const side = Math.ceil(pins/2), startX = -((side-1)*P)/2;
      for(let i=0; i<side; i++) { ctx.fillRect(startX+i*P-padW/2, -bodyH/2, padW, -padLen); if (i+side<pins) ctx.fillRect(startX+i*P-padW/2, bodyH/2, padW, padLen); }
    }
    ctx.rotate(-90 * Math.PI / 180);
  }
  else if(info.type === SHAPES.SOP) {
    const bodyH = info.W || (h * 0.6); ctx.fillRect(-w/2, -bodyH/2, w, bodyH); ctx.strokeRect(-w/2, -bodyH/2, w, bodyH);
    ctx.beginPath(); ctx.arc(-w/2+w*0.1, -bodyH/2+bodyH*0.2, 0.2, 0, 2*Math.PI); ctx.fillStyle = status.isHover?"red":"#999"; ctx.fill();
    ctx.fillStyle = padFill; const sidePins = Math.floor((info.pins||8)/2), P = info.P || 1.27, startX = -((sidePins - 1) * P) / 2, padW = P*0.5, padLen = (h-bodyH)/2;
    for(let i=0; i<sidePins; i++) { const px = startX + i*P; ctx.fillRect(px-padW/2, -h/2, padW, padLen); ctx.fillRect(px-padW/2, bodyH/2, padW, padLen); }
  }
  else if(info.type === SHAPES.CHIP) { const padW = w*0.25; ctx.fillStyle = padFill; ctx.fillRect(-w/2, -h/2, padW, h); ctx.fillRect(w/2-padW, -h/2, padW, h); ctx.fillStyle = fill; ctx.fillRect(-w/2+padW, -h/2, w-2*padW, h); ctx.strokeRect(-w/2, -h/2, w, h); }
  else if(info.type === SHAPES.CIRCLE) { const r=Math.min(w,h)/2; ctx.beginPath(); ctx.arc(0,0,r,0,2*Math.PI); ctx.fillStyle=fill; ctx.fill(); ctx.stroke(); ctx.fillStyle="#333"; ctx.fillRect(-r/2,-r,r,r/2); }
  else { ctx.fillRect(-w/2, -h/2, w, h); ctx.strokeRect(-w/2, -h/2, w, h); ctx.beginPath(); ctx.arc(-w/2+w*0.15, -h/2+h*0.15, Math.min(w,h)*0.1, 0, 2*Math.PI); ctx.fillStyle = status.isHover?"red":"#ccc"; ctx.fill(); }
}

function parseRows(rows) {
  if (!rows || rows.length < 2) return [];
  let hIdx = 0; for(let i=0;i<Math.min(rows.length,5);i++){ const s=rows[i].join(" ").toLowerCase(); if(s.includes("designator")||s.includes("mid x")) { hIdx=i; break; } }
  const h = rows[hIdx].map(x=>String(x).trim().toLowerCase());
  const find = ks => h.findIndex(c => ks.some(k => c.includes(k)));
  const iRef=find(["designator","ref"]), iX=find(["mid x","x(mm)"]), iY=find(["mid y","y(mm)"]), iLayer=find(["layer","Â±Ç"]), iVal=find(["value","ÂÄº"]), iFp=find(["footprint","Â∞ÅË£Ö"]), iName=find(["name", "comment", "Â§áÊ≥®", "device"]), iRot=find(["rotation","angle"]);
  if(iRef<0 || iX<0 || iY<0) return [];
  const num = v => parseFloat(String(v).replace(/mm/g,"")) || 0;
  return rows.slice(hIdx+1).filter(r=>r&&r[iRef]).map(r=>{
    const fp = iFp>=0 ? String(r[iFp]||"") : "", layerRaw = iLayer>=0 ? String(r[iLayer]||"").toUpperCase() : "T";
    const info = analyzeFootprint(fp), bounds = calculateBounds(fp, info);
    return { ref: r[iRef], x: num(r[iX]), y: num(r[iY]), angle: iRot>=0?num(r[iRot]):0, layer: layerRaw.includes("B")||layerRaw.includes("BOTTOM")?"B":"T", w: bounds.w, h: bounds.h, val: iVal>=0?String(r[iVal]||""):"", name: iName>=0 ? String(r[iName]||"") : "", fp: fp, shapeInfo: info, checked: false };
  });
}

function makeViewer(allComps){
  const cvs = document.getElementById("pcb"); const ctx = cvs.getContext("2d");
  const dpr = window.devicePixelRatio || 1;
  let t = { k:15, x:0, y:0 }, sel = null, hoveredComp = null, checkedSet = new Set(), filteredComps = [];
  
  function updateFilter() { filteredComps = allComps.filter(c => c.layer === document.querySelector('input[name="layer"]:checked').value); renderList(); draw(); }

  function renderList() {
    const list = document.getElementById("list"); list.innerHTML = "";
    const keys = document.getElementById("search").value.toUpperCase().trim().split(/\s+/).filter(k=>k);
    const toShow = filteredComps.filter(c => !keys.length || keys.every(k => (c.ref+c.val+c.name).toUpperCase().includes(k))).slice(0, 500);
    if(!toShow.length) { list.innerHTML="<div style='padding:20px;text-align:center;color:#666'>Êó†Êï∞ÊçÆ</div>"; return;}
    const frag = document.createDocumentFragment();
    toShow.forEach(c => {
      const div = document.createElement("div"); div.className = "item"; div.id = "i-"+c.ref; if(checkedSet.has(c.ref)) div.classList.add("checked");
      div.innerHTML = `<div style="flex:1"><b>${c.ref}</b><span>${(c.val&&c.val!=="-")?c.val:c.name}</span></div><span style="color:#666;font-size:10px">${c.fp}</span>`;
      div.onclick = () => highlight(c.ref); div.ondblclick = () => toggleCheck(c.ref); frag.appendChild(div);
    });
    list.appendChild(frag);
  }

  function draw() {
    const W = cvs.width/dpr, H = cvs.height/dpr; ctx.clearRect(0,0,W,H);
    ctx.save(); ctx.translate(t.x, t.y); ctx.scale(t.k, -t.k);
    const curLayer = document.querySelector('input[name="layer"]:checked').value; if(curLayer === 'B') ctx.scale(-1, 1);
    
    filteredComps.forEach(c => {
      const isSel = (c.ref === sel), isHover = (c === hoveredComp);
      // „Äê‰øÆÂ§çÂÖ≥ÈîÆ„ÄëÔºöÂπ≥ÊùøÊ®°Âºè‰∏ãÔºåÂ¶ÇÊûúÂΩìÂâçË¢´ÈÄâ‰∏≠(sel)Â≠òÂú®ÔºåÂàô‰ª•Ë¢´ÈÄâ‰∏≠ÂÖÉ‰ª∂‰∏∫ÁõÆÊ†áËøõË°åÂåπÈÖç
      const targetComp = isHover ? c : (sel ? filteredComps.find(x=>x.ref===sel) : null);
      
      // ÂåπÈÖçÈÄªËæëÔºöÈùûËá™Ë∫´„ÄÅÈùûÊÇ¨ÂÅú„ÄÅÈùûÈÄâ‰∏≠Ôºå‰ΩÜÂèÇÊï∞‰∏ÄËá¥
      const isMatch = targetComp && !isHover && !isSel && c.val && c.val!=="-" && c.val === targetComp.val && c.fp === targetComp.fp;
      
      ctx.save(); ctx.translate(c.x, c.y); ctx.rotate(c.angle * Math.PI/180);
      drawComponent(ctx, c, { isSel, isChecked: checkedSet.has(c.ref), isHover, isMatch });
      ctx.restore();

      if(c.w * t.k > 15) {
        ctx.save(); ctx.translate(c.x, c.y); if(curLayer === 'B') ctx.scale(-1, 1); ctx.scale(1, -1); 
        let txt = c.ref; if(document.querySelector('input[name="mode"]:checked').value==="value") { const v = (c.val&&c.val!=="-")?c.val:c.name; if(v&&v!=="-") txt = v; }
        let fs = Math.max(12/t.k, 0.2); if(fs>2) fs=2;
        ctx.font = `bold ${fs}px Arial`; ctx.textAlign="center"; ctx.textBaseline="middle";
        // ‰ºòÂÖàÁ∫ßÔºöÊÇ¨ÂÅú > ÂåπÈÖç > ÈÄâ‰∏≠ > Â∑≤ÁÑä > ÊôÆÈÄö
        ctx.fillStyle = isHover?"#d00":(isMatch?"#0056b3":(isSel?"#bf360c":(checkedSet.has(c.ref)?"#1b5e20":"#333")));
        ctx.fillText(txt, 0, 0); ctx.restore();
      }
    });
    ctx.restore();
  }

  function resize() {
    const r = cvs.parentElement.getBoundingClientRect();
    const w = Math.floor(r.width * dpr), h = Math.floor(r.height * dpr);
    if(cvs.width !== w || cvs.height !== h) { cvs.width = w; cvs.height = h; ctx.scale(dpr, dpr); }
    cvs.style.width = r.width + "px"; cvs.style.height = r.height + "px";
  }
  
  function fit() { resize(); if(!filteredComps.length){draw();return;} let x0=1e9,x1=-1e9,y0=1e9,y1=-1e9; filteredComps.forEach(c=>{x0=Math.min(x0,c.x-c.w/2);x1=Math.max(x1,c.x+c.w/2);y0=Math.min(y0,c.y-c.h/2);y1=Math.max(y1,c.y+c.h/2);}); const s = Math.min((cvs.width/dpr)/(x1-x0||10), (cvs.height/dpr)/(y1-y0||10)) * 0.9; t.k = s; t.x = (cvs.width/dpr)/2 - (x0 + x1)/2 * s; t.y = (cvs.height/dpr)/2 + (y0 + y1)/2 * s; draw(); }

  function toggleCheck(ref) { if(checkedSet.has(ref)) checkedSet.delete(ref); else checkedSet.add(ref); const el = document.getElementById("i-"+ref); if(el) el.classList.toggle("checked"); draw(); showToast(ref + (checkedSet.has(ref) ? " Â∑≤ÂÆåÊàê" : " Êí§ÈîÄÂÆåÊàê")); }

  function highlight(ref) {
    sel = ref; hoveredComp = null; draw();
    const el = document.getElementById("i-"+ref);
    if(el) { document.querySelectorAll(".active").forEach(e=>e.classList.remove("active")); el.classList.add("active"); el.scrollIntoView({block:"nearest"}); const c = filteredComps.find(x => x.ref === ref); updateInfo(c); }
  }

  function updateInfo(c) { document.getElementById("info-panel").innerHTML = c ? [["‰ΩçÂè∑",c.ref],["ÂÄº",c.val],["Name",c.name],["Â∞ÅË£Ö",c.fp],["ÂùêÊ†á",`${c.x},${c.y}`]].map(([k,v])=>`<div class="info-row"><div class="info-label">${k}</div><div class="info-val">${v||'-'}</div></div>`).join("") : "<div style='color:#666;text-align:center;margin-top:40px;'>ÈÄâ‰∏≠ÂÖÉ‰ª∂Êü•ÁúãËØ¶ÊÉÖ</div>"; }

  // === ÈáçÊñ∞ËÆæËÆ°ÁöÑ‰∫ã‰ª∂Á≥ªÁªü (ÂÆåÁæéËß£ÂÜ≥ÂπΩÁÅµÁÇπÂáª) ===
  let drag = false, isTouch = false, lastX = 0, lastY = 0, lastDist = 0, lastTapTime = 0;

  const handleTap = (cx, cy, isDbl) => {
      const r = cvs.getBoundingClientRect();
      const curLayer = document.querySelector('input[name="layer"]:checked').value;
      let px = cx - r.left - t.x, py = cy - r.top - t.y; if(curLayer === 'B') px = -px;
      const wx = px/t.k, wy = py/-t.k;
      let hit = null; for(let i=filteredComps.length-1; i>=0; i--) { const c=filteredComps[i]; if(Math.abs(wx-c.x)<=c.w/2 && Math.abs(wy-c.y)<=c.h/2){ hit=c; break; } }
      if(isDbl && hit) toggleCheck(hit.ref); 
      else highlight(hit ? hit.ref : null);
  };

  // Ëß¶Êéß
  cvs.addEventListener('touchstart', e => {
    e.preventDefault(); // ÈòªÊ≠¢‰∫ßÁîüÂêéÁª≠ÁöÑÈº†Ê†á‰∫ã‰ª∂
    isTouch = true;
    if (e.touches.length === 1) { drag = true; lastX = e.touches[0].clientX; lastY = e.touches[0].clientY; } 
    else if (e.touches.length === 2) { drag = false; const t1=e.touches[0], t2=e.touches[1]; lastDist=Math.hypot(t2.clientX-t1.clientX, t2.clientY-t1.clientY); }
  }, {passive: false});

  cvs.addEventListener('touchmove', e => {
    e.preventDefault();
    if (e.touches.length === 1 && drag) {
      const cx = e.touches[0].clientX, cy = e.touches[0].clientY;
      if(Math.hypot(cx-lastX, cy-lastY) > 2) { // ÂæÆÂä®ÂÆπÂ∑Æ
        t.x += cx - lastX; t.y += cy - lastY; lastX = cx; lastY = cy; draw();
      }
    } else if (e.touches.length === 2) {
      const t1=e.touches[0], t2=e.touches[1]; const dist=Math.hypot(t2.clientX-t1.clientX, t2.clientY-t1.clientY);
      if (lastDist > 0) {
        const scale = dist / lastDist; const cx=(t1.clientX+t2.clientX)/2-cvs.getBoundingClientRect().left, cy=(t1.clientY+t2.clientY)/2-cvs.getBoundingClientRect().top;
        t.x = cx - (cx - t.x) * scale; t.y = cy - (cy - t.y) * scale; t.k *= scale; draw();
      }
      lastDist = dist;
    }
  }, {passive: false});

  cvs.addEventListener('touchend', e => {
    e.preventDefault(); // ÂÖ≥ÈîÆÔºÅÈòªÊ≠¢ click/mousedown ‰∫ßÁîü
    drag = false;
    if (e.changedTouches.length === 1) {
        // Â¶ÇÊûúÊ≤°ÂèëÁîüÊòéÊòæÁßªÂä®ÔºåËßÜ‰∏∫ÁÇπÂáª
        const cx = e.changedTouches[0].clientX, cy = e.changedTouches[0].clientY;
        const now = Date.now();
        if(Math.hypot(cx-lastX, cy-lastY) < 5) { // Âà§ÂÆö‰∏∫ Tap
            // 300ms ÂÜÖÁÆóÂèåÂáª
            if(now - lastTapTime < 300) { handleTap(cx, cy, true); lastTapTime = 0; }
            else { handleTap(cx, cy, false); lastTapTime = now; }
        }
    }
  });

  // Èº†Ê†á (‰ªÖÂΩìÈùûËß¶Êë∏Êó∂Ëß¶Âèë)
  cvs.onmousedown = e => { if(isTouch)return; drag=true; lastX=e.clientX; lastY=e.clientY; };
  window.onmousemove = e => { 
    if(isTouch)return; 
    if(e.buttons===1 && drag){ t.x+=e.clientX-lastX; t.y+=e.clientY-lastY; lastX=e.clientX; lastY=e.clientY; draw(); } 
    else { // Hover (‰ªÖÈº†Ê†á)
      const r = cvs.getBoundingClientRect(); const curLayer = document.querySelector('input[name="layer"]:checked').value;
      let px = e.clientX - r.left - t.x, py = e.clientY - r.top - t.y; if(curLayer === 'B') px = -px;
      const wx = px/t.k, wy = py/-t.k;
      let hit = null; for(let i=filteredComps.length-1; i>=0; i--) { const c=filteredComps[i]; if(Math.abs(wx-c.x)<=c.w/2 && Math.abs(wy-c.y)<=c.h/2){ hit=c; break; } }
      if(hit !== hoveredComp) { hoveredComp = hit; draw(); }
    }
  };
  window.onmouseup = e => { 
    if(isTouch)return; drag=false; 
    if(Math.hypot(e.clientX-lastX, e.clientY-lastY) < 5) {
      // ÁÆÄÂçïÁöÑÈº†Ê†áÁÇπÂáª/ÂèåÂáªÂå∫ÂàÜ
      const cx=e.clientX, cy=e.clientY; const now=Date.now();
      if(now - lastTapTime < 300) { handleTap(cx,cy,true); lastTapTime=0; } else { handleTap(cx,cy,false); lastTapTime=now; }
    }
  };
  cvs.onwheel = e => { e.preventDefault(); const r=cvs.getBoundingClientRect(); const d=e.deltaY>0?0.9:1.1; t.x = (e.clientX-r.left)-((e.clientX-r.left)-t.x)*d; t.y = (e.clientY-r.top)-((e.clientY-r.top)-t.y)*d; t.k*=d; draw(); };

  document.getElementById("reset").onclick = fit;
  return { load: ()=>{ updateFilter(); fit(); }, update: updateFilter };
}

let comps = [], viewer = null; const fileIn = document.getElementById("file"); let sTimer;
document.getElementById("search").oninput = () => { clearTimeout(sTimer); sTimer = setTimeout(() => { if(viewer) viewer.update(); }, 300); };
fileIn.onchange = e => {
  const f = e.target.files[0]; if(!f) return; const r = new FileReader();
  r.onload = evt => {
    let rows=[]; const d=evt.target.result;
    if(f.name.match(/\.xls/)){ try{const wb=XLSX.read(d,{type:'array'});rows=XLSX.utils.sheet_to_json(wb.Sheets[wb.SheetNames[0]],{header:1});}catch(e){alert("Error");return;} }
    else { rows = (new TextDecoder().decode(new Uint8Array(d))).split(/\r?\n/).map(l=>l.split(/,|\t/)); }
    comps = parseRows(rows); if(!comps.length) return alert("No Data Found");
    viewer = makeViewer(comps); viewer.load(); document.querySelector('.btn').textContent = "üìÇ "+f.name;
  }; r.readAsArrayBuffer(f);
};
document.querySelectorAll('input[type="radio"]').forEach(r => { r.addEventListener('change', () => { if(viewer) viewer.update(); }); });
window.onresize = () => { if(viewer) viewer.load(); };
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>PCB ç„Šæ¥åŠ©æ‰‹ (Excel/CSV å…¨èƒ½ç‰ˆ)</title>
<!-- å¼•å…¥ SheetJS ç”¨äºè§£æ Excel -->
<script src="https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js"></script>

<style>
  :root {
    --sidebar-bg: #2b2d30;
    --sidebar-text: #adb0b8;
    --accent-color: #4a88c7;
    --selected-bg: #2675bf;
    --canvas-bg: #f0f2f5;
  }
  * { box-sizing: border-box; }
  body {
    margin: 0; padding: 0;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    height: 100vh; display: flex; overflow: hidden; background-color: var(--canvas-bg);
  }

  /* ä¾§è¾¹æ  */
  aside {
    width: 320px; background-color: var(--sidebar-bg); color: var(--sidebar-text);
    display: flex; flex-direction: column; border-right: 1px solid #1e1e1e; z-index: 20;
  }
  .header { padding: 10px; background-color: #1e1f22; border-bottom: 1px solid #3e4145; }
  h2 { margin: 0 0 8px 0; font-size: 16px; color: #fff; }
  .view-mode { display: flex; gap: 10px; margin-bottom: 8px; font-size: 12px; color: #fff; }
  .view-mode label { display: flex; align-items: center; cursor: pointer; }
  .view-mode input { margin-right: 4px; }
  .file-upload { position: relative; overflow: hidden; margin-bottom: 8px; }
  .file-upload input { position: absolute; left: 0; top: 0; opacity: 0; width: 100%; height: 100%; cursor: pointer; }
  .btn { display: block; background-color: var(--accent-color); color: white; text-align: center; padding: 8px; border-radius: 4px; font-size: 14px; transition: 0.2s; }
  .btn:hover { opacity: 0.9; }
  #search { width: 100%; padding: 8px; border-radius: 4px; border: 1px solid #555; background: #1e1f22; color: #fff; }
  #list-container { flex: 1; overflow-y: auto; -webkit-overflow-scrolling: touch; }
  .comp-item { padding: 10px; border-bottom: 1px solid #3e4145; display: flex; flex-direction: column; cursor: pointer; }
  .comp-item.active { background-color: var(--selected-bg); color: #fff; }
  .comp-ref { font-weight: bold; font-size: 15px; }
  .comp-desc { font-size: 12px; opacity: 0.8; margin-top: 2px; }
  #info-panel { padding: 10px; background: #1e1f22; border-top: 1px solid #3e4145; font-size: 12px; height: 140px; overflow-y: auto; }
  .info-row { display: flex; margin-bottom: 4px; border-bottom: 1px dashed #444; }
  .info-label { width: 60px; color: #888; }
  .info-val { flex: 1; color: #ddd; word-break: break-all; }

  /* ç”»å¸ƒ */
  main {
    flex: 1; position: relative; overflow: hidden;
    background-image: radial-gradient(#ccc 1px, transparent 1px);
    background-size: 20px 20px; touch-action: none;
  }
  canvas { display: block; width: 100%; height: 100%; }
  #reset-btn {
    position: absolute; top: 10px; right: 10px;
    background: white; border: 1px solid #999; padding: 5px 10px;
    border-radius: 4px; font-size: 12px; cursor: pointer;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2); z-index: 5;
  }

  /* å“åº”å¼ */
  @media (max-width: 768px) {
    body { flex-direction: column-reverse; }
    aside { width: 100%; height: 45%; border-right: none; border-top: 1px solid #3e4145; }
    main { height: 55%; }
    #info-panel { display: none; }
  }
</style>
</head>
<body>

<aside>
  <div class="header">
    <h2>PCB ç„Šæ¥åŠ©æ‰‹</h2>
    <div class="file-upload">
      <!-- æ¥å— xlsx, xls, csv, txt -->
      <div class="btn">ğŸ“‚ å¯¼å…¥æ–‡ä»¶ (Excel / CSV)</div>
      <input type="file" id="file" accept=".csv,.tsv,.txt,.xlsx,.xls">
    </div>
    
    <div class="view-mode">
      <label><input type="radio" name="mode" value="value" checked> æ˜¾ç¤ºå‚æ•°</label>
      <label><input type="radio" name="mode" value="ref"> æ˜¾ç¤ºä½å·</label>
    </div>

    <input type="text" id="search" placeholder="ğŸ” æœä½å· (ä¾‹å¦‚ R1)...">
  </div>

  <div id="list-container">
    <div style="padding:20px; text-align:center; opacity:0.5;">æ”¯æŒ Excel (.xlsx/.xls) å’Œ CSV</div>
  </div>

  <div id="info-panel">
    <div style="color:#aaa; padding-top:10px">
      æ”¯æŒ Excel ç›´æ¥å¯¼å…¥<br>
      æ»šè½®/åŒæŒ‡ç¼©æ”¾ï¼Œæ‹–æ‹½å¹³ç§»
    </div>
  </div>
</aside>

<main>
  <button id="reset-btn">ğŸ”„ å¤ä½è§†å›¾</button>
  <canvas id="pcb"></canvas>
</main>

<script>
// ========== 1. æ•°æ®è§£æ (ç»Ÿä¸€å¤„ç† CSV å’Œ Excel) ==========

// å°è£…ä¼°ç®—å°ºå¯¸
function estimateSize(footprint){
  const fp = (footprint || "").toUpperCase();
  let mL = fp.match(/L([\d.]+)/), mW = fp.match(/W([\d.]+)/);
  if (mL && mW) return { w: parseFloat(mL[1]) || 2, h: parseFloat(mW[1]) || 1 };
  if (fp.includes("0402")) return { w:1.0, h:0.5 };
  if (fp.includes("0603")) return { w:1.6, h:0.8 };
  if (fp.includes("0805")) return { w:2.0, h:1.25 };
  if (fp.includes("1206")) return { w:3.2, h:1.6 };
  if (fp.includes("SOT-23")) return { w:2.9, h:1.6 };
  if (fp.includes("SOP-8")) return { w:5.0, h:4.0 };
  if (fp.includes("QFN")) return { w:4.0, h:4.0 };
  return { w:2.0, h:1.0 };
}

// æ ¸å¿ƒé€»è¾‘ï¼šæ— è®ºæ˜¯ CSV è¿˜æ˜¯ Excelï¼Œæœ€ç»ˆéƒ½è½¬æˆâ€œè¡Œæ•°ç»„â€æ¥å¤„ç†
function processRows(rows) {
  if (!rows || rows.length < 2) return [];

  // 1. å¯»æ‰¾è¡¨å¤´è¡Œ (æœ‰æ—¶ Excel ç¬¬ä¸€è¡Œæ˜¯æ ‡é¢˜ï¼Œç¬¬äºŒè¡Œæ‰æ˜¯è¡¨å¤´)
  // æˆ‘ä»¬æ‰¾åŒ…å« "Designator" æˆ– "Ref" æˆ– "Mid X" çš„é‚£ä¸€è¡Œ
  let headerIndex = 0;
  let headerNorm = [];
  
  for(let i=0; i<Math.min(rows.length, 5); i++) {
    const rowStr = rows[i].join(" ").toLowerCase();
    if(rowStr.includes("designator") || rowStr.includes("mid x") || rowStr.includes("mid_x")) {
      headerIndex = i;
      headerNorm = rows[i].map(x => String(x).trim().toLowerCase());
      break;
    }
  }

  // å¦‚æœæ²¡æ‰¾åˆ°æ˜æ˜¾çš„è¡¨å¤´ï¼Œé»˜è®¤ç”¨ç¬¬0è¡Œ
  if(headerNorm.length === 0) headerNorm = rows[0].map(x => String(x).trim().toLowerCase());

  const findCol = keys => headerNorm.findIndex(h => keys.some(k => h.includes(k)));
  
  const iRef = findCol(["designator","ref"]);
  const iMidX = findCol(["mid x","x(mm)","mid_x"]);
  const iMidY = findCol(["mid y","y(mm)","mid_y"]);
  const iRot = findCol(["rotation","rot","è§’åº¦"]);
  const iCom = findCol(["comment","å¤‡æ³¨"]);
  const iVal = findCol(["value","å€¼"]);
  const iFp = findCol(["footprint","å°è£…"]);
  const iLayer = findCol(["layer","å±‚"]);

  if (iRef < 0 || iMidX < 0 || iMidY < 0) return [];

  const num = str => (!str) ? NaN : parseFloat(String(str).replace(/mm/gi,"").replace(/[^\d.+\-eE]/g,""));

  const comps = [];
  // ä»è¡¨å¤´ä¸‹ä¸€è¡Œå¼€å§‹éå†
  for (let li = headerIndex + 1; li < rows.length; li++) {
    const row = rows[li];
    if (!row || row.length === 0) continue;

    const ref = row[iRef]; 
    if(!ref) continue;

    // åªè¦é¡¶å±‚
    if(iLayer >= 0) {
        const l = String(row[iLayer] || "").toUpperCase();
        if(l.startsWith("B")) continue;
    }

    const x = num(row[iMidX]), y = num(row[iMidY]);
    if (isNaN(x) || isNaN(y)) continue;
    
    let angle = iRot >= 0 ? num(row[iRot]) : 0;
    
    const fpStr = iFp >= 0 ? String(row[iFp] || "") : "";
    const sz = estimateSize(fpStr);
    
    comps.push({
      ref: String(ref), 
      x, y, 
      angle: isNaN(angle)?0:angle,
      w: sz.w, h: sz.h,
      comment: iCom>=0 ? String(row[iCom] || "") : "",
      value: iVal>=0 ? String(row[iVal] || "") : "",
      footprint: fpStr
    });
  }
  return comps;
}

// ========== 2. äº¤äº’å¼ Viewer (ä¿æŒä¹‹å‰çš„å®Œç¾é€»è¾‘) ==========
function makeViewer(comps){
  const canvas = document.getElementById("pcb");
  const ctx = canvas.getContext("2d");
  const dpr = window.devicePixelRatio || 1;
  let transform = { k: 15, x: 0, y: 0 };
  let selectedRef = null;
  let isDragging = false;
  let lastPos = { x: 0, y: 0 };
  let lastDist = 0; 

  function resize() {
    const rect = canvas.parentElement.getBoundingClientRect();
    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;
    ctx.scale(dpr, dpr);
    canvas.style.width = rect.width + "px";
    canvas.style.height = rect.height + "px";
    requestAnimationFrame(draw);
  }
  window.addEventListener('resize', resize);
  resize();

  function fitView(){
    if(!comps.length) return;
    let minX=1e9, maxX=-1e9, minY=1e9, maxY=-1e9;
    comps.forEach(c => {
      minX = Math.min(minX, c.x - c.w/2); maxX = Math.max(maxX, c.x + c.w/2);
      minY = Math.min(minY, c.y - c.h/2); maxY = Math.max(maxY, c.y + c.h/2);
    });
    const pcbW = maxX - minX + 4; 
    const pcbH = maxY - minY + 4;
    const centerX = (minX + maxX) / 2;
    const centerY = (minY + maxY) / 2;
    const screenW = canvas.width / dpr;
    const screenH = canvas.height / dpr;
    const scale = Math.min(screenW / pcbW, screenH / pcbH) * 0.9;
    
    transform.k = scale;
    transform.x = screenW/2 - centerX * scale;
    transform.y = screenH/2 + centerY * scale; 
    requestAnimationFrame(draw);
  }

  function screenToWorld(sx, sy) {
    const rect = canvas.getBoundingClientRect();
    const px = sx - rect.left;
    const py = sy - rect.top;
    const worldX = (px - transform.x) / transform.k;
    const worldY = (py - transform.y) / -transform.k;
    return { x: worldX, y: worldY };
  }

  function draw(){
    const width = canvas.width / dpr;
    const height = canvas.height / dpr;
    ctx.clearRect(0, 0, width, height);

    ctx.save();
    ctx.translate(transform.x, transform.y);
    ctx.scale(transform.k, -transform.k); 
    ctx.lineWidth = 1 / transform.k; 

    const mode = document.querySelector('input[name="mode"]:checked').value;

    for (const c of comps) {
      const isSelected = (c.ref === selectedRef);
      ctx.save();
      ctx.translate(c.x, c.y);
      ctx.rotate(c.angle * Math.PI / 180);
      
      if (isSelected) {
        ctx.fillStyle = "rgba(255, 0, 0, 0.3)";
        ctx.strokeStyle = "#ff0000";
        ctx.lineWidth = 2 / transform.k;
      } else {
        ctx.fillStyle = "#fff";
        ctx.strokeStyle = "#666";
      }
      ctx.fillRect(-c.w/2, -c.h/2, c.w, c.h);
      ctx.strokeRect(-c.w/2, -c.h/2, c.w, c.h);
      
      ctx.beginPath();
      ctx.arc(-c.w/2 + c.w*0.15, -c.h/2 + c.h*0.15, Math.min(c.w,c.h)*0.1, 0, 2*Math.PI);
      ctx.fillStyle = isSelected ? "red" : "#ccc"; ctx.fill();
      ctx.restore();

      if (c.w * transform.k > 15) {
        ctx.save();
        ctx.translate(c.x, c.y);
        ctx.scale(1, -1); 
        let txt = c.ref;
        if(mode === "value") {
           // é€»è¾‘ï¼šValue -> Comment -> Ref
           const val = (c.value && c.value.trim() !== "" && c.value !== "-") ? c.value : 
                       ((c.comment && c.comment.trim() !== "" && c.comment !== "-") ? c.comment : c.ref);
           if(val) txt = val;
        }
        ctx.font = `bold ${12/transform.k}px Arial`;
        // å­—ä½“å¤§å°é™åˆ¶ (é˜²æ­¢æ— é™å¤§)
        if(12/transform.k > 20) ctx.font = `bold 20px Arial`;
        
        ctx.fillStyle = isSelected ? "#d00" : "#333";
        ctx.textAlign = "center"; ctx.textBaseline = "middle";
        ctx.fillText(txt, 0, 0);
        ctx.restore();
      }
    }
    ctx.restore();
  }

  // --- äº‹ä»¶ç›‘å¬ ---
  canvas.addEventListener("wheel", e => {
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    const delta = e.deltaY > 0 ? 0.9 : 1.1;
    transform.x = mx - (mx - transform.x) * delta;
    transform.y = my - (my - transform.y) * delta;
    transform.k *= delta;
    requestAnimationFrame(draw);
  }, { passive: false });

  function startDrag(x, y) { isDragging = true; lastPos = { x, y }; }
  function moveDrag(x, y) {
    if (isDragging) {
      transform.x += x - lastPos.x;
      transform.y += y - lastPos.y;
      lastPos = { x, y };
      requestAnimationFrame(draw);
    }
  }
  function endDrag() { isDragging = false; }

  canvas.addEventListener("mousedown", e => startDrag(e.clientX, e.clientY));
  window.addEventListener("mousemove", e => moveDrag(e.clientX, e.clientY));
  window.addEventListener("mouseup", endDrag);

  canvas.addEventListener("touchstart", e => {
    if(e.touches.length === 1) startDrag(e.touches[0].clientX, e.touches[0].clientY);
    else if (e.touches.length === 2) {
      isDragging = false;
      const t1 = e.touches[0], t2 = e.touches[1];
      lastDist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
    }
  }, { passive: false });

  canvas.addEventListener("touchmove", e => {
    e.preventDefault();
    if(e.touches.length === 1) moveDrag(e.touches[0].clientX, e.touches[0].clientY);
    else if (e.touches.length === 2) {
      const t1 = e.touches[0], t2 = e.touches[1];
      const dist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
      const cx = (t1.clientX + t2.clientX) / 2 - canvas.getBoundingClientRect().left;
      const cy = (t1.clientY + t2.clientY) / 2 - canvas.getBoundingClientRect().top;
      const delta = dist / lastDist;
      lastDist = dist;
      transform.x = cx - (cx - transform.x) * delta;
      transform.y = cy - (cy - transform.y) * delta;
      transform.k *= delta;
      requestAnimationFrame(draw);
    }
  }, { passive: false });
  canvas.addEventListener("touchend", endDrag);

  let downX=0, downY=0;
  canvas.addEventListener("mousedown", e=>{ downX=e.clientX; downY=e.clientY; });
  canvas.addEventListener("mouseup", e=>{
    if(Math.abs(e.clientX-downX)<5 && Math.abs(e.clientY-downY)<5) handleClick(e.clientX, e.clientY);
  });
  let tDownX=0, tDownY=0;
  canvas.addEventListener("touchstart", e=>{ if(e.touches.length===1){ tDownX=e.touches[0].clientX; tDownY=e.touches[0].clientY;} });
  canvas.addEventListener("touchend", e=>{
    if(e.changedTouches.length===1){
      const tx = e.changedTouches[0].clientX, ty = e.changedTouches[0].clientY;
      if(Math.abs(tx-tDownX)<10 && Math.abs(ty-tDownY)<10) handleClick(tx, ty);
    }
  });

  function handleClick(sx, sy) {
    const p = screenToWorld(sx, sy);
    let hit = null;
    for(const c of comps) {
      if (Math.abs(p.x - c.x) <= c.w/2 && Math.abs(p.y - c.y) <= c.h/2) { hit = c; break; }
    }
    if(hit) highlight(hit.ref);
    else { selectedRef=null; requestAnimationFrame(draw); renderList(comps); }
  }

  function highlight(ref) {
    selectedRef = ref;
    requestAnimationFrame(draw);
    const item = document.getElementById("item-"+ref);
    if(item) {
      document.querySelectorAll(".comp-item.active").forEach(el=>el.classList.remove("active"));
      item.classList.add("active");
      item.scrollIntoView({ behavior: "smooth", block: "nearest" });
      const c = comps.find(x=>x.ref===ref);
      updateInfo(c);
    }
  }

  document.getElementById("reset-btn").onclick = fitView;
  fitView();
  return highlight;
}

// ========== 3. æ–‡ä»¶å¤„ç†ä¸ UI ==========
const fileInput = document.getElementById("file");
const searchInput = document.getElementById("search");
const listContainer = document.getElementById("list-container");
const infoPanel = document.getElementById("info-panel");
let allComps = [];
let setHighlight = null;

document.querySelectorAll('input[name="mode"]').forEach(r => {
  r.addEventListener('change', () => { if(allComps.length && setHighlight) setHighlight(null); });
});

fileInput.addEventListener("change", e => {
  const f = e.target.files[0];
  if(!f) return;
  document.querySelector('.btn').textContent = "æ­£åœ¨å¤„ç†...";
  
  const reader = new FileReader();
  
  reader.onload = (e) => {
    const data = e.target.result;
    let rows = [];

    // åˆ¤æ–­æ˜¯ Excel è¿˜æ˜¯ CSV
    if (f.name.endsWith('.xlsx') || f.name.endsWith('.xls')) {
      // Excel æ¨¡å¼
      try {
        const workbook = XLSX.read(data, {type: 'array'});
        const firstSheetName = workbook.SheetNames[0];
        const worksheet = workbook.Sheets[firstSheetName];
        // è½¬æ¢æˆäºŒç»´æ•°ç»„ [[A1,B1..],[A2,B2..]]
        rows = XLSX.utils.sheet_to_json(worksheet, {header: 1});
      } catch (err) {
        alert("Excel è§£æå¤±è´¥ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶æ˜¯å¦åŠ å¯†");
        document.querySelector('.btn').textContent = "å¯¼å…¥å¤±è´¥";
        return;
      }
    } else {
      // CSV/Text æ¨¡å¼
      const decoder = new TextDecoder("utf-8"); // ç®€å•å¤„ç†ï¼Œå‡è®¾ UTF-8
      // å…¼å®¹ä¹‹å‰çš„è§£ç é€»è¾‘
      let text = "";
      const bytes = new Uint8Array(data);
      if (bytes.length >= 2 && bytes[0]===0xFF && bytes[1]===0xFE) {
        for (let i=2;i+1<bytes.length;i+=2) text += String.fromCharCode(bytes[i]|(bytes[i+1]<<8));
      } else {
        text = decoder.decode(bytes);
      }
      
      // è½¬æˆäºŒç»´æ•°ç»„
      const lines = text.split(/\r?\n/).filter(l => l.trim() !== "");
      // è‡ªåŠ¨åˆ¤æ–­åˆ†éš”ç¬¦
      if(lines.length > 0) {
          const l0 = lines[0];
          const delim = l0.includes("\t") ? "\t" : (l0.includes(";") ? ";" : ",");
          rows = lines.map(l => l.split(delim).map(s => s.trim()));
      }
    }

    // ç»Ÿä¸€å¤„ç†
    allComps = processRows(rows);
    document.querySelector('.btn').textContent = "ğŸ“‚ " + f.name;
    
    if(!allComps.length) { 
      alert("æœªè¯†åˆ«åˆ°å…ƒä»¶æ•°æ®ã€‚è¯·ç¡®ä¿æ–‡ä»¶åŒ…å« Designator(Ref), Mid X, Mid Y åˆ—"); 
      return; 
    }
    
    setHighlight = makeViewer(allComps);
    renderList(allComps);
  };
  
  reader.readAsArrayBuffer(f);
});

function renderList(comps){
  listContainer.innerHTML = "";
  if(!comps.length) { listContainer.innerHTML="<div style='padding:20px;text-align:center;color:#666'>æ— </div>"; return; }
  const renderLimit = comps.length > 2000 ? 500 : comps.length;
  for(let i=0; i<renderLimit; i++){
    const c = comps[i];
    const d = document.createElement("div"); d.className="comp-item"; d.id="item-"+c.ref;
    // åˆ—è¡¨æ˜¾ç¤ºï¼šä½å· + (Valueä¼˜å…ˆ > Comment)
    const val = (c.value && c.value.trim()!== "" && c.value!=="-") ? c.value : c.comment;
    d.innerHTML = `<span class="comp-ref">${c.ref}</span><span class="comp-desc">${val||""} ${c.footprint||""}</span>`;
    d.onclick = () => { if(setHighlight) setHighlight(c.ref); };
    listContainer.appendChild(d);
  }
}

searchInput.addEventListener("input", e=>{
  const kw = e.target.value.trim().toUpperCase();
  const f = allComps.filter(c=> 
    c.ref.includes(kw) || 
    (c.value && c.value.toUpperCase().includes(kw)) ||
    (c.comment && c.comment.toUpperCase().includes(kw))
  );
  renderList(f);
});

function updateInfo(c){
  if(!c) return;
  const rows = [["ä½å·",c.ref],["å€¼",c.value],["å¤‡æ³¨",c.comment],["å°è£…",c.footprint],["åæ ‡",`${c.x},${c.y}`]];
  let h = ""; rows.forEach(([k,v])=>h+=`<div class="info-row"><div class="info-label">${k}</div><div class="info-val">${v||'-'}</div></div>`);
  infoPanel.innerHTML = h;
}
</script>
</body>
</html>
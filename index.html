<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>PCB ç„Šæ¥åŠ©æ‰‹ (ç§»åŠ¨ç«¯é€‚é…ç‰ˆ)</title>
<style>
  :root {
    --sidebar-bg: #2b2d30;
    --sidebar-text: #adb0b8;
    --accent-color: #4a88c7;
    --selected-bg: #2675bf;
    --canvas-bg: #f0f2f5;
  }

  * { box-sizing: border-box; }

  body {
    margin: 0; padding: 0;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    height: 100vh;
    display: flex;
    overflow: hidden;
    background-color: var(--canvas-bg);
  }

  /* === ä¾§è¾¹æ  (PCç«¯) === */
  aside {
    width: 320px;
    background-color: var(--sidebar-bg);
    color: var(--sidebar-text);
    display: flex;
    flex-direction: column;
    border-right: 1px solid #1e1e1e;
    z-index: 20;
    transition: all 0.3s;
  }

  .header { padding: 10px; background-color: #1e1f22; border-bottom: 1px solid #3e4145; }
  h2 { margin: 0 0 8px 0; font-size: 16px; color: #fff; }

  .view-mode { display: flex; gap: 10px; margin-bottom: 8px; font-size: 12px; color: #fff; }
  .view-mode label { display: flex; align-items: center; }

  .file-upload { position: relative; overflow: hidden; margin-bottom: 8px; }
  .file-upload input { position: absolute; left: 0; top: 0; opacity: 0; width: 100%; height: 100%; }
  .btn { display: block; background-color: var(--accent-color); color: white; text-align: center; padding: 8px; border-radius: 4px; font-size: 14px; }
  
  #search { width: 100%; padding: 8px; border-radius: 4px; border: 1px solid #555; background: #1e1f22; color: #fff; }

  #list-container { flex: 1; overflow-y: auto; -webkit-overflow-scrolling: touch; }
  
  .comp-item { padding: 10px; border-bottom: 1px solid #3e4145; display: flex; flex-direction: column; cursor: pointer; }
  .comp-item.active { background-color: var(--selected-bg); color: #fff; }
  .comp-ref { font-weight: bold; font-size: 15px; }
  .comp-desc { font-size: 12px; opacity: 0.8; margin-top: 2px; }

  #info-panel { padding: 10px; background: #1e1f22; border-top: 1px solid #3e4145; font-size: 12px; height: 140px; overflow-y: auto; }
  .info-row { display: flex; margin-bottom: 4px; border-bottom: 1px dashed #444; }
  .info-label { width: 60px; color: #888; }
  .info-val { flex: 1; color: #ddd; word-break: break-all; }

  /* === ç”»å¸ƒåŒºåŸŸ === */
  main {
    flex: 1;
    position: relative;
    overflow: hidden;
    background-image: radial-gradient(#ccc 1px, transparent 1px);
    background-size: 20px 20px;
    touch-action: none; /* ç¦æ­¢æµè§ˆå™¨é»˜è®¤ç¼©æ”¾ */
  }

  canvas { display: block; width: 100%; height: 100%; }

  /* å¤ä½æŒ‰é’® */
  #reset-btn {
    position: absolute; top: 10px; right: 10px;
    background: white; border: 1px solid #999;
    padding: 5px 10px; border-radius: 4px;
    font-size: 12px; cursor: pointer;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    z-index: 5;
  }

  /* === ç§»åŠ¨ç«¯å“åº”å¼å¸ƒå±€ === */
  @media (max-width: 768px) {
    body { flex-direction: column-reverse; } /* åˆ—è¡¨åœ¨ä¸‹ï¼Œå›¾åœ¨ä¸Š */
    
    aside {
      width: 100%;
      height: 45%; /* åˆ—è¡¨å æ®ä¸‹æ–¹ 45% */
      border-right: none;
      border-top: 1px solid #3e4145;
    }
    
    main { height: 55%; } /* å›¾å æ®ä¸Šæ–¹ 55% */
    
    /* è°ƒæ•´æ‰‹æœºä¸Šçš„å­—ä½“å’Œé—´è· */
    .comp-item { padding: 8px 12px; }
    #info-panel { height: 100px; display: none; } /* æ‰‹æœºå±å¤ªå°ï¼Œæš‚æ—¶éšè—è¯¦ç»†ä¿¡æ¯ï¼Œåªçœ‹åˆ—è¡¨ */
  }
</style>
</head>
<body>

<aside>
  <div class="header">
    <h2>PCB ç„Šæ¥åŠ©æ‰‹</h2>
    <div class="file-upload">
      <div class="btn">ğŸ“‚ å¯¼å…¥ CSV åæ ‡æ–‡ä»¶</div>
      <input type="file" id="file" accept=".csv,.tsv,.txt">
    </div>
    
    <div class="view-mode">
      <label><input type="radio" name="mode" value="value" checked> æ˜¾ç¤ºå‚æ•°</label>
      <label><input type="radio" name="mode" value="ref"> æ˜¾ç¤ºä½å·</label>
    </div>

    <input type="text" id="search" placeholder="ğŸ” æœä½å· (ä¾‹å¦‚ R1)...">
  </div>

  <div id="list-container">
    <div style="padding:20px; text-align:center; opacity:0.5;">è¯·å…ˆå¯¼å…¥æ–‡ä»¶</div>
  </div>

  <div id="info-panel">
    <div style="color:#aaa; padding-top:10px">
      PC: æ»šè½®ç¼©æ”¾ / æ‹–æ‹½å¹³ç§»<br>
      Mobile: åŒæŒ‡ç¼©æ”¾ / å•æŒ‡å¹³ç§»
    </div>
  </div>
</aside>

<main>
  <button id="reset-btn">ğŸ”„ å¤ä½è§†å›¾</button>
  <canvas id="pcb"></canvas>
</main>

<script>
// ========== 1. æ•°æ®è§£æ (ä¿æŒæ ¸å¿ƒé€»è¾‘ä¸å˜) ==========
function decodeFileText(buf){
  const bytes = new Uint8Array(buf);
  if (bytes.length >= 2 && bytes[0] === 0xFF && bytes[1] === 0xFE) {
    let out = ""; for (let i = 2; i + 1 < bytes.length; i += 2) out += String.fromCharCode(bytes[i] | (bytes[i+1] << 8)); return out;
  }
  if (bytes.length >= 2 && bytes[0] === 0xFE && bytes[1] === 0xFF) {
    let out = ""; for (let i = 2; i + 1 < bytes.length; i += 2) out += String.fromCharCode((bytes[i] << 8) | bytes[i+1]); return out;
  }
  return new TextDecoder("utf-8").decode(bytes);
}

function estimateSize(footprint){
  const fp = (footprint || "").toUpperCase();
  let mL = fp.match(/L([\d.]+)/), mW = fp.match(/W([\d.]+)/);
  if (mL && mW) return { w: parseFloat(mL[1]) || 2, h: parseFloat(mW[1]) || 1 };
  if (fp.includes("0402")) return { w:1.0, h:0.5 };
  if (fp.includes("0603")) return { w:1.6, h:0.8 };
  if (fp.includes("0805")) return { w:2.0, h:1.25 };
  if (fp.includes("1206")) return { w:3.2, h:1.6 };
  if (fp.includes("SOT-23")) return { w:2.9, h:1.6 };
  if (fp.includes("SOP-8")) return { w:5.0, h:4.0 };
  if (fp.includes("QFN")) return { w:4.0, h:4.0 };
  return { w:2.0, h:1.0 };
}

function parseCSV(text){
  text = text.replace(/\u0000/g,"");
  const lines = text.split(/\r?\n/).filter(l => l.trim() !== "");
  if (lines.length < 2) return [];
  let headerLine = lines[0].replace(/^\uFEFF/,"");
  let delim = headerLine.includes("\t") ? "\t" : (headerLine.includes(";") ? ";" : ",");
  const rawHeader = headerLine.split(delim).map(s => s.trim());
  const headerNorm = rawHeader.map(h => h.toLowerCase());
  
  const findCol = keys => headerNorm.findIndex(h => keys.some(k => h.includes(k)));
  const iRef = findCol(["designator","ref"]);
  const iMidX = findCol(["mid x","x(mm)","mid_x"]);
  const iMidY = findCol(["mid y","y(mm)","mid_y"]);
  const iRot = findCol(["rotation","rot","è§’åº¦"]);
  const iCom = findCol(["comment","å¤‡æ³¨"]);
  const iVal = findCol(["value","å€¼"]);
  const iFp = findCol(["footprint","å°è£…"]);
  const iLayer = findCol(["layer","å±‚"]);

  if (iRef < 0 || iMidX < 0 || iMidY < 0) return [];
  const num = str => (!str) ? NaN : parseFloat(String(str).replace(/mm/gi,"").replace(/[^\d.+\-eE]/g,""));

  const comps = [];
  for (let li = 1; li < lines.length; li++) {
    const row = lines[li].split(delim).map(s => s.trim());
    if(!row[iRef]) continue;
    // é»˜è®¤åªæ˜¾ç¤º Top å±‚ (å¦‚æœæ²¡å±‚ä¿¡æ¯é»˜è®¤æ˜¾ç¤º)
    if(iLayer >= 0) {
        const l = (row[iLayer] || "").toUpperCase();
        if(l.startsWith("B")) continue;
    }
    const x = num(row[iMidX]), y = num(row[iMidY]);
    if (isNaN(x) || isNaN(y)) continue;
    let angle = iRot >= 0 ? num(row[iRot]) : 0;
    
    const sz = estimateSize(iFp >=0 ? row[iFp] : "");
    comps.push({
      ref: row[iRef], x, y, angle: isNaN(angle)?0:angle,
      w: sz.w, h: sz.h,
      comment: iCom>=0 ? row[iCom] : "",
      value: iVal>=0 ? row[iVal] : "",
      footprint: iFp>=0 ? row[iFp] : ""
    });
  }
  return comps;
}

// ========== 2. äº¤äº’å¼æŸ¥çœ‹å™¨ (æ ¸å¿ƒå‡çº§) ==========
function makeViewer(comps){
  const canvas = document.getElementById("pcb");
  const ctx = canvas.getContext("2d");
  const dpr = window.devicePixelRatio || 1;

  // è§†å›¾çŠ¶æ€
  let transform = { k: 15, x: 0, y: 0 }; // k: ç¼©æ”¾æ¯”ä¾‹, x/y: å¹³ç§»åç§»é‡
  let selectedRef = null;
  let isDragging = false;
  let lastPos = { x: 0, y: 0 };
  let lastDist = 0; // åŒæŒ‡è·ç¦»

  // åˆå§‹åŒ– Canvas å°ºå¯¸
  function resize() {
    const rect = canvas.parentElement.getBoundingClientRect();
    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;
    ctx.scale(dpr, dpr);
    canvas.style.width = rect.width + "px";
    canvas.style.height = rect.height + "px";
    requestAnimationFrame(draw);
  }
  window.addEventListener('resize', resize);
  resize();

  // è‡ªåŠ¨é€‚åº”è§†å›¾
  function fitView(){
    if(!comps.length) return;
    let minX=1e9, maxX=-1e9, minY=1e9, maxY=-1e9;
    comps.forEach(c => {
      minX = Math.min(minX, c.x - c.w/2); maxX = Math.max(maxX, c.x + c.w/2);
      minY = Math.min(minY, c.y - c.h/2); maxY = Math.max(maxY, c.y + c.h/2);
    });
    // PCB ç‰©ç†å°ºå¯¸
    const pcbW = maxX - minX + 4; // åŠ ç‚¹è¾¹è·
    const pcbH = maxY - minY + 4;
    const centerX = (minX + maxX) / 2;
    const centerY = (minY + maxY) / 2;

    // å±å¹•å°ºå¯¸
    const screenW = canvas.width / dpr;
    const screenH = canvas.height / dpr;

    // è®¡ç®—ç¼©æ”¾
    const scale = Math.min(screenW / pcbW, screenH / pcbH) * 0.9;
    
    transform.k = scale;
    // è®¡ç®—å¹³ç§»ï¼šä½¿ PCB ä¸­å¿ƒ å¯¹é½ å±å¹•ä¸­å¿ƒ
    // å±å¹•ä¸­å¿ƒ = (PCBä¸­å¿ƒ * ç¼©æ”¾) + åç§»
    // åç§» = å±å¹•ä¸­å¿ƒ - (PCBä¸­å¿ƒ * ç¼©æ”¾)
    // æ³¨æ„ï¼šYè½´æ˜¯ç¿»è½¬çš„ï¼ŒåŸå§‹åæ ‡ y å‘ä¸Šï¼Œå±å¹• y å‘ä¸‹
    // è¿™é‡Œæˆ‘ä»¬å…ˆç»Ÿä¸€é€»è¾‘ï¼šdrawçš„æ—¶å€™å†å¤„ç† Y ç¿»è½¬
    transform.x = screenW/2 - centerX * scale;
    transform.y = screenH/2 + centerY * scale; // Yè½´åè½¬ç‰¹ä¾‹å¤„ç†

    requestAnimationFrame(draw);
  }

  // åæ ‡è½¬æ¢ï¼šå±å¹•åƒç´  -> PCB ç‰©ç†åæ ‡
  function screenToWorld(sx, sy) {
    const rect = canvas.getBoundingClientRect();
    const px = sx - rect.left;
    const py = sy - rect.top;
    
    // é€†è¿ç®—
    // drawX = worldX * k + tx
    // worldX = (drawX - tx) / k
    const wx = (px - transform.x) / transform.k;
    // drawY = height - (worldY * k + ty)  <-- Yè½´ç¿»è½¬é€»è¾‘
    // worldY * k = height - drawY - ty
    // worldY = (height - drawY - ty) / k  
    // ç­‰ç­‰ï¼Œæˆ‘ä»¬åœ¨ draw é‡Œç”¨çš„å˜æ¢çŸ©é˜µæ˜¯ç®€å•çš„ translate/scale
    // è®©æˆ‘ä»¬åœ¨ draw å‡½æ•°é‡Œçœ‹ä»”ç»†ï¼š
    // ctx.translate(transform.x, transform.y);
    // ctx.scale(transform.k, -transform.k); // ç¿»è½¬Y
    
    // æ‰€ä»¥ï¼š
    // px = wx * k + tx
    // py = wy * (-k) + ty
    
    const worldX = (px - transform.x) / transform.k;
    const worldY = (py - transform.y) / -transform.k;
    return { x: worldX, y: worldY };
  }

  function draw(){
    const width = canvas.width / dpr;
    const height = canvas.height / dpr;
    
    ctx.clearRect(0, 0, width, height);
    
    // ç»˜åˆ¶ç½‘æ ¼èƒŒæ™¯ (å¯é€‰)
    ctx.save();
    ctx.strokeStyle = "#e5e5e5";
    ctx.lineWidth = 1;
    const gridSize = 10 * transform.k;
    /* çœç•¥ç½‘æ ¼ç»˜åˆ¶ä»¥ä¿æŒæ€§èƒ½ï¼Œå¦‚æœéœ€è¦å¯ä»¥åŠ  */
    ctx.restore();

    ctx.save();
    // === åº”ç”¨å˜æ¢çŸ©é˜µ ===
    ctx.translate(transform.x, transform.y);
    ctx.scale(transform.k, -transform.k); // Yè½´å‘ä¸Šä¸ºæ­£ï¼Œå±å¹•å‘ä¸‹ä¸ºæ­£ï¼Œæ‰€ä»¥ Scale Y = -k

    ctx.lineWidth = 1 / transform.k; // ä¿æŒçº¿å®½æ’å®š

    const mode = document.querySelector('input[name="mode"]:checked').value;

    for (const c of comps) {
      const isSelected = (c.ref === selectedRef);
      
      ctx.save();
      ctx.translate(c.x, c.y);
      ctx.rotate(c.angle * Math.PI / 180);
      
      // æœ¬ä½“
      if (isSelected) {
        ctx.fillStyle = "rgba(255, 0, 0, 0.3)";
        ctx.strokeStyle = "#ff0000";
        ctx.lineWidth = 2 / transform.k;
      } else {
        ctx.fillStyle = "#fff";
        ctx.strokeStyle = "#666";
      }
      
      ctx.fillRect(-c.w/2, -c.h/2, c.w, c.h);
      ctx.strokeRect(-c.w/2, -c.h/2, c.w, c.h);
      
      // 1è„š
      ctx.beginPath();
      ctx.arc(-c.w/2 + c.w*0.15, -c.h/2 + c.h*0.15, Math.min(c.w,c.h)*0.1, 0, 2*Math.PI);
      ctx.fillStyle = isSelected ? "red" : "#ccc";
      ctx.fill();
      
      ctx.restore();

      // æ–‡å­— (ä¿æŒä¸æ—‹è½¬ä¸”å¤§å°åˆé€‚)
      // åªæœ‰å½“å™¨ä»¶åœ¨å±å¹•ä¸Šè¶³å¤Ÿå¤§æ‰æ˜¾ç¤ºæ–‡å­—
      if (c.w * transform.k > 15) {
        ctx.save();
        ctx.translate(c.x, c.y);
        ctx.scale(1, -1); // æŠŠæ–‡å­—å†ç¿»è½¬å›æ¥ï¼Œå˜æˆæ­£çš„

        // æ™ºèƒ½æ˜¾ç¤ºå†…å®¹
        let txt = c.ref;
        if(mode === "value") {
           const val = (c.value && c.value !== "-") ? c.value : c.comment;
           if(val && val.trim() !== "") txt = val;
        }

        // å­—ä½“å¤„ç†ï¼šè§†å›¾ç¼©æ”¾å¾ˆå¤§æ—¶ï¼Œå­—ä½“å¤§å°è¦å—é™ï¼Œä¸èƒ½æ— é™å¤§
        // åŸºç¡€å­—å· 12px / transform.k (åœ¨ç‰©ç†ç©ºé—´çš„å¤§å°) -> æŠ•å½±å›å±å¹•å°±æ˜¯ 12px
        let fontSize = 12 / transform.k; 
        // ä¿®æ­£ï¼šæˆ‘ä»¬å¸Œæœ›æ–‡å­—åœ¨å±å¹•ä¸Šçœ‹èµ·æ¥å·®ä¸å¤šå¤§ï¼Œæˆ–è€…éšç¼©æ”¾ç¨å¾®å˜å¤§
        // ç›´æ¥è®¾ç½®å±å¹•åƒç´ å­—å·ï¼Œç„¶åé™¤å» scale
        // æˆ‘ä»¬å¸Œæœ›å±å¹•ä¸Šæ–‡å­—å¤§çº¦ 10-12px
        ctx.font = `bold ${12/transform.k}px Arial`;
        
        ctx.fillStyle = isSelected ? "#d00" : "#333";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(txt, 0, 0);
        ctx.restore();
      }
    }
    ctx.restore();
  }

  // ========== äº‹ä»¶ç›‘å¬ (é¼ æ ‡ + è§¦æ‘¸) ==========

  // 1. é¼ æ ‡æ»šè½®ç¼©æ”¾
  canvas.addEventListener("wheel", e => {
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    
    const delta = e.deltaY > 0 ? 0.9 : 1.1; // ç¼©æ”¾ç³»æ•°
    
    // ä»¥é¼ æ ‡ä¸ºä¸­å¿ƒç¼©æ”¾å…¬å¼ï¼š
    // new_tx = mx - (mx - tx) * delta
    transform.x = mx - (mx - transform.x) * delta;
    transform.y = my - (my - transform.y) * delta;
    transform.k *= delta;
    
    requestAnimationFrame(draw);
  }, { passive: false });

  // 2. é¼ æ ‡/å•æŒ‡ æ‹–æ‹½
  function startDrag(x, y) {
    isDragging = true;
    lastPos = { x, y };
  }
  
  function moveDrag(x, y) {
    if (isDragging) {
      const dx = x - lastPos.x;
      const dy = y - lastPos.y;
      transform.x += dx;
      transform.y += dy;
      lastPos = { x, y };
      requestAnimationFrame(draw);
    }
  }

  function endDrag() { isDragging = false; }

  // é¼ æ ‡äº‹ä»¶
  canvas.addEventListener("mousedown", e => startDrag(e.clientX, e.clientY));
  window.addEventListener("mousemove", e => moveDrag(e.clientX, e.clientY));
  window.addEventListener("mouseup", endDrag);

  // è§¦æ‘¸äº‹ä»¶ (æ”¯æŒåŒæŒ‡ç¼©æ”¾)
  canvas.addEventListener("touchstart", e => {
    if(e.touches.length === 1) {
      startDrag(e.touches[0].clientX, e.touches[0].clientY);
    } else if (e.touches.length === 2) {
      // åŒæŒ‡å¼€å§‹
      isDragging = false;
      const t1 = e.touches[0];
      const t2 = e.touches[1];
      lastDist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
    }
  }, { passive: false });

  canvas.addEventListener("touchmove", e => {
    e.preventDefault(); // é˜²æ­¢æ»šåŠ¨é¡µé¢
    if(e.touches.length === 1) {
      moveDrag(e.touches[0].clientX, e.touches[0].clientY);
    } else if (e.touches.length === 2) {
      // åŒæŒ‡ç¼©æ”¾
      const t1 = e.touches[0];
      const t2 = e.touches[1];
      const dist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
      
      // ä¸­å¿ƒç‚¹
      const cx = (t1.clientX + t2.clientX) / 2 - canvas.getBoundingClientRect().left;
      const cy = (t1.clientY + t2.clientY) / 2 - canvas.getBoundingClientRect().top;

      const delta = dist / lastDist;
      lastDist = dist;

      transform.x = cx - (cx - transform.x) * delta;
      transform.y = cy - (cy - transform.y) * delta;
      transform.k *= delta;

      requestAnimationFrame(draw);
    }
  }, { passive: false });

  canvas.addEventListener("touchend", endDrag);

  // ç‚¹å‡»é€‰ä¸­é€»è¾‘
  canvas.addEventListener("click", e => {
    // å¦‚æœåˆšåˆšå‘ç”Ÿäº†æ‹–åŠ¨ï¼Œåˆ™ä¸è®¤ä¸ºæ˜¯ç‚¹å‡»
    // è¿™é‡Œç®€å•å¤„ç†ï¼Œå¦‚æœæƒ³åšç»†å¯ä»¥åˆ¤æ–­ down å’Œ up çš„è·ç¦»
    // æš‚ä¸”ç›´æ¥åˆ¤å®š
  });
  
  // ç‹¬ç«‹çš„ç‚¹å‡»åˆ¤å®šï¼ˆä¸ºäº†ä¸å’Œæ‹–æ‹½å†²çªï¼Œç”¨ MouseUp ä¸”ä½ç§»å¾ˆå°æ¥åˆ¤å®šï¼‰
  let downX=0, downY=0;
  canvas.addEventListener("mousedown", e=>{ downX=e.clientX; downY=e.clientY; });
  canvas.addEventListener("mouseup", e=>{
    if(Math.abs(e.clientX-downX)<5 && Math.abs(e.clientY-downY)<5){
      // è®¤ä¸ºæ˜¯ç‚¹å‡»
      handleClick(e.clientX, e.clientY);
    }
  });
  
  // è§¦æ‘¸ç‚¹å‡»
  let tDownX=0, tDownY=0;
  canvas.addEventListener("touchstart", e=>{ if(e.touches.length===1){ tDownX=e.touches[0].clientX; tDownY=e.touches[0].clientY;} });
  canvas.addEventListener("touchend", e=>{
    if(e.changedTouches.length===1){
      const tx = e.changedTouches[0].clientX;
      const ty = e.changedTouches[0].clientY;
      if(Math.abs(tx-tDownX)<10 && Math.abs(ty-tDownY)<10){
        handleClick(tx, ty);
      }
    }
  });

  function handleClick(sx, sy) {
    const p = screenToWorld(sx, sy);
    // å¯»æ‰¾æœ€è¿‘çš„å…ƒä»¶
    let hit = null;
    // ç®€å•çš„çŸ©å½¢åˆ¤å®šï¼Œå¿½ç•¥æ—‹è½¬
    for(const c of comps) {
      if (Math.abs(p.x - c.x) <= c.w/2 && Math.abs(p.y - c.y) <= c.h/2) {
        hit = c;
        break; // æ‰¾åˆ°ä¸€ä¸ªå°±åœï¼Œæˆ–è€…æ‰¾æœ€è¿‘çš„
      }
    }
    
    if(hit) highlight(hit.ref);
    else { selectedRef=null; requestAnimationFrame(draw); renderList(comps); }
  }

  // å¯¹å¤–æ¥å£
  function highlight(ref) {
    selectedRef = ref;
    requestAnimationFrame(draw);
    
    // åˆ—è¡¨è”åŠ¨
    const item = document.getElementById("item-"+ref);
    if(item) {
      document.querySelectorAll(".comp-item.active").forEach(el=>el.classList.remove("active"));
      item.classList.add("active");
      item.scrollIntoView({ behavior: "smooth", block: "nearest" }); // mobileä¸Šcenterå¯èƒ½é®æŒ¡
      
      const c = comps.find(x=>x.ref===ref);
      updateInfo(c);
    }
  }

  document.getElementById("reset-btn").onclick = fitView;

  fitView();
  return highlight;
}

// ========== 3. UI é€»è¾‘ ==========
const fileInput = document.getElementById("file");
const searchInput = document.getElementById("search");
const listContainer = document.getElementById("list-container");
const infoPanel = document.getElementById("info-panel");
let allComps = [];
let setHighlight = null;

// ç›‘å¬æ¨¡å¼åˆ‡æ¢
document.querySelectorAll('input[name="mode"]').forEach(r => {
  r.addEventListener('change', () => {
    // è§¦å‘ä¸€æ¬¡é‡ç»˜ï¼Œç®€å•åŠæ³•æ˜¯å¤ä½æˆ–è€…æ¨¡æ‹Ÿç‚¹å‡»
    // ç”±äºé‡ç»˜é€»è¾‘åœ¨ makeViewer é—­åŒ…é‡Œï¼Œè¿™é‡Œæˆ‘ä»¬æœ€å¥½é‡æ–°è§¦å‘ fit æˆ–è€… expose redraw
    // å·æ‡’åšæ³•ï¼šé‡æ–°ç”Ÿæˆä¸€æ¬¡ (æ€§èƒ½æ¶ˆè€—ä¸å¤§)
    if(allComps.length && setHighlight) setHighlight(null); // åªæ˜¯ä¸ºäº†é‡ç»˜
  });
});

fileInput.addEventListener("change", e => {
  const f = e.target.files[0];
  if(!f) return;
  const reader = new FileReader();
  reader.onload = () => {
    allComps = parseCSV(decodeFileText(reader.result));
    document.querySelector('.btn').textContent = "ğŸ“‚ " + f.name;
    if(!allComps.length) { alert("æ— æ•°æ®"); return; }
    setHighlight = makeViewer(allComps);
    renderList(allComps);
  };
  reader.readAsArrayBuffer(f);
});

function renderList(comps){
  listContainer.innerHTML = "";
  if(!comps.length) { listContainer.innerHTML="<div style='padding:20px;text-align:center;color:#666'>æ— </div>"; return; }
  // é™åˆ¶æ¸²æŸ“æ•°é‡é˜²æ­¢å¡é¡¿ (å¦‚æœå…ƒä»¶æœ‰å‡ åƒä¸ª)
  const renderLimit = comps.length > 2000 ? 500 : comps.length;
  
  for(let i=0; i<renderLimit; i++){
    const c = comps[i];
    const d = document.createElement("div"); d.className="comp-item"; d.id="item-"+c.ref;
    const val = (c.value && c.value!=="-") ? c.value : c.comment;
    d.innerHTML = `<span class="comp-ref">${c.ref}</span><span class="comp-desc">${val} ${c.footprint}</span>`;
    d.onclick = () => { if(setHighlight) setHighlight(c.ref); };
    listContainer.appendChild(d);
  }
}

searchInput.addEventListener("input", e=>{
  const kw = e.target.value.trim().toUpperCase();
  const f = allComps.filter(c=> c.ref.includes(kw) || (c.value && c.value.toUpperCase().includes(kw)));
  renderList(f);
});

function updateInfo(c){
  if(!c) return;
  const rows = [["ä½å·",c.ref],["å€¼",c.value],["å¤‡æ³¨",c.comment],["å°è£…",c.footprint],["åæ ‡",`${c.x},${c.y}`]];
  let h = ""; rows.forEach(([k,v])=>h+=`<div class="info-row"><div class="info-label">${k}</div><div class="info-val">${v||'-'}</div></div>`);
  infoPanel.innerHTML = h;
}

</script>
</body>
</html>